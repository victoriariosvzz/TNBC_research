---
title: "TNBC_pipeline"
author: "Victoria Rios"
date: "14/6/2021"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Data Analysis of BRCA TNBC TCGA


## Data Pre-processing--------------------------------------------------------------------------------------------------------------

We avoid strings being recognized as factors
```{r}
options(stringsAsFactors = F)
```

Reading clinical data
```{r}
raw_brca_clin <- read.delim(file = "BRCA.clin.merged.txt", sep = "\t", header = F,
row.names = 1, as.is = T)
```

Obtaining the data for the 3 receptors (by visually recognizing the rows in the dataset)
```{r}
receptor_rows <- c(24,29,1160) # we may need to change the values of the receptor rows according to each specific dataset

print(rownames(raw_brca_clin)[receptor_rows])
```
Index of triple negative (TN) samples 
```{r}
index_TN <- which(as.character(raw_brca_clin[receptor_rows[1],]) == "negative" &
as.character(raw_brca_clin[receptor_rows[2],]) == "negative" &
as.character(raw_brca_clin[receptor_rows[3],]) == "negative")
```

Filtering to obtain only Triple Negative data and obtain the key of the samples (patient barcodes)
```{r}
brca_clin <- raw_brca_clin[,index_TN]
tn_samples <- toupper(as.character(brca_clin[21,])) # patient barcode row
```

Reading RNAseq data
```{r}
f <- "BRCA.rnaseqv2__illuminahiseq_rnaseqv2__unc_edu__Level_3__RSEM_genes_normalized__data.data.txt"
brca_rnaseq <- read.delim(file = f, sep="\t", as.is=T, row.names = 1)
raw_brca_rnaseq <- data.matrix(brca_rnaseq[-1,])
```

Extracting gene symbols
```{r}
gene_symbols <- as.character(sapply(rownames(raw_brca_rnaseq), function(x)
unlist(strsplit(x = x, split = "\\|"))[1]))
```

Drop rows with a gene symbol equal to “?”
```{r}
brca_rnaseq <- raw_brca_rnaseq[which(gene_symbols != "?"),]
gene_symbols <- gene_symbols[which(gene_symbols != "?")]
```

Observe the type of sample according to the TCGA barcode and delete the normal (type "11") https://docs.gdc.
cancer.gov/Encyclopedia/pages/TCGA_Barcode/
```{r}
sample_type <- substr(x = colnames(brca_rnaseq), start = 14, stop = 15)
brca_rnaseq <- brca_rnaseq[,-which(sample_type == "11")]
sample_type <- sample_type[-which(sample_type == "11")]
```

Match between TN samples (clinical) and RNAseq data
```{r}
tn_match <- match(gsub(pattern = "-", replacement = "\\.", x = tn_samples),
substr(x = colnames(brca_rnaseq), start = 1, stop = 12))
tn_match_na <- which(is.na(tn_match))
brca_clin <- brca_clin[,-tn_match_na]
tn_samples <- tn_samples[-tn_match_na]
tn_match <- tn_match[-tn_match_na]
brca_rnaseq <- brca_rnaseq[,tn_match]

brca_rnaseq_t <- t(brca_rnaseq) # Transpose of Rnaseq 

```

# Normalization of the dataset
```{r}
brca_rnaseq_n <- log2(brca_rnaseq_t + 1)
```

## Dimensions reduction--------------------------------------------------------------------------------------------------------------

PCA
```{r}
# Principal components analysis

x <- prcomp(brca_rnaseq_n, scale = FALSE)
```

Visualize eigenvalues (scree plot)
```{r}
library(factoextra)

#Show the percentage of variances explained by each principal component.
fviz_eig(x)
```

Re-labeling the patients IDs
```{r}
# We check that the patient ID doesn't repeat
temp <- table(x[["x"]])

isTRUE(any(temp > 1)) # if the result is FALSE, they appear only once
```
We save the original IDs in another list inside of x
```{r}
orig_IDs <- matrix(row.names(x[["x"]]), ncol = 1) # we store the original IDs
short_IDs <- as.character(matrix(data = 1:nrow(x[["x"]]), ncol = 1)) # we store the short IDs

IDs <- cbind(orig_IDs, short_IDs) # we bind them in the same matrix


x[["IDs"]] <- IDs # We append the new IDs matrix to the x list
```

We proceed to assign a unique number to each patient
```{r}
row.names(x[["x"]]) <- short_IDs

head(x[["x"]])
```

Graph of individuals

We plot to visualize the short IDs of each patient
```{r}
fviz_pca_ind(x,
             col.ind = "cos2", # Color by the quality of representation
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = T,     # Avoid text overlapping,
             max.overlaps = Inf
             )
```

# Clustering

## Consensus clustering ---------------------------------------------------------------------------------------------------------

```{r}
# Coordinates of individuals
ind.coord <- as.data.frame(get_pca_ind(x)$coord)

head(ind.coord)
```
Loading the library
```{r}
library(M3C)
# now we have loaded the mydata and desx objects (with the package automatically)
# mydata is the expression data for GBM
# desx is the annotation for this data
```

PCA
```{r}
data_pca <- pca(brca_rnaseq_n,legendtextsize = 10,axistextsize = 10,dotsize=2)
```
Performing the consensus clustering on the normalized data
```{r}
# for vignette
res <- M3C(t(brca_rnaseq_n), removeplots = TRUE, iters=25, objective='PAC', fsize=8, lthick=1, dotsize=1.25)

optimal_k_pac = max(res[["assignments"]]);
```
# Checking the scores

The scores and p values are contained within the res$scores object. We can see below the RCSI reaches a maxima at K = 2, the p value supports this optimal K decision. This means the null hypothesis that K = 1 can be rejected for this dataset because we have achieved significance (alpha=0.05) versus a dataset with no clusters.

```{r}
res$scores
```

# Checking the plots

1. CDF Plot

In the CDF and following PAC plot we can see the inherant bias of consensus clustering where as K increases so does the apparent stability of the results (or CDF plot flatness), this we correct for by using a reference. This makes the method more sensitive to detection of the underlying structure in noisy data.

```{r}
res$plots[[1]]
```

2. PAC Score

This figure above shows the PAC score, we can see an elbow at K = 5 which is suggestive this is the best K. However, the bias of consensus clustering can be seen here as the PAC score naturally tends towards lower values as K increases (see above plot), making selecting K without taking this into account subject to bias. Selecting the minimal PAC score will only work when the clusters are very well seperated.


```{r}
res$plots[[2]]
```

3. Relative Cluster Stability Index (RCSI)

We derive the Relative Cluster Stability Index (RCSI) and associated 95% confidence intervals which take into account the reference PAC scores using the reference mean. This metric is better than the PAC score for deciding class number, where the maximum value corresponds to the optimal K. In this example the RCSI has an optima at K=2. Either the RCSI or p values can be used to select K, in the Bioinformatics paper we used M3C with the p values to select K 

```{r}
res$plots[[4]]
```

4. P values

Finally, we calculate a p value from the distribution, here we display the p values from the beta distribution. If none of the p values reach significance over a reasonable range of K (e.g. 10), then we accept the null hypothesis. In the GBM dataset, we can see K = 2 reaches signfiicance with an alpha of 0.05, therefore we can reject the null hypothesis K=1 for the GBM dataset.
```{r}
res$plots[[3]]
```

# Entropy objective function

We use information entropy and aim to minimise it to find K, where lower values correspond to less uncertainty in the system (more stability during resampling). Whilst this function often gives pretty similar results to the PAC score, it makes better theoretical sense because it does not rely on a subjective window, neither does it rely on calculating a CDF first and a metric from this CDF second.

```{r}
res_entropy <- M3C(t(brca_rnaseq_n), method = 2,fsize=8, lthick=1, dotsize=1.25, removeplots = TRUE)

optimal_k_entropy = max(res_entropy$assignments)
```

```{r}
res_entropy$plots[[2]]
```
Comparing both consensus clustering methods optimal K
```{r}
if (optimal_k_pac == optimal_k_entropy){
  k_clusters = optimal_k_pac
  
  print(paste0("The optimal k clusters value is: ", as.character(k_clusters)))
}
```
Now we are pretty convinced there are 2 clusters within this dataset which are not likely simply to have
occurred by chance alone. We can turn to examine the output objects that M3C generates.


# Understanding M3C Outputs

The 3 lines below extract the ordered (according in clustering results) expression data and the ordered annotation data from the results object after running M3C for a 2 cluster solution. We then take a look at the annotation object M3C outputs, a consensus cluster column has been added by M3C.

```{r}
# k_clusters = 5 # uncomment to test other k values

data <- res$realdataresults[[k_clusters]]$ordered_data
annon <- res$realdataresults[[k_clusters]]$ordered_annotation     # the ordered data (cluster 1 and cluster 2)
ccmatrix <- res$realdataresults[[k_clusters]]$consensus_matrix

head(annon)
```

Consensus matrix heatmaps from M3C output with ComplexHeatmap.

```{r}
 library(ComplexHeatmap)

 ccl <- list()
 x <- c("skyblue", "gold", "violet", "darkorchid", "slateblue", "forestgreen",
 "violetred", "orange", "midnightblue", "grey31", "black")
 names(x) <- as.character(seq(1,11,by=1))
 for (i in seq(2,k_clusters)){
 # get cc matrix and labels
 ccmatrix <- res$realdataresults[[i]]$consensus_matrix
 annon <- res$realdataresults[[i]]$ordered_annotation
 # do heatmap
 n <- 10
 seq <- rev(seq(0,255,by=255/(n)))
 palRGB <- cbind(seq,seq,255)
 mypal <- rgb(palRGB,maxColorValue=255)
 ha = HeatmapAnnotation(
 df= data.frame(Cluster=as.character(annon[,1])), col = list(Cluster=x))
 ccl[[i]] <- Heatmap(ccmatrix, name = "Consensus_index", top_annotation = ha,
 col=mypal, show_row_dend = FALSE,
 show_column_dend = FALSE, cluster_rows = FALSE, cluster_columns = FALSE,
 show_column_names = FALSE)
 }
 
 print(ccl)
```

# Visual check of consensus cluster structure

```{r}
pca(data, labels = annon$consensuscluster,legendtextsize = 10,axistextsize = 10,dotsize=2)

```

Defining the cluster groups with the patient IDs

```{r}
library(dplyr)

cluster = list()

for (i in seq(1, k_clusters)) { 
                                cluster[[i]] <- filter(annon, annon$consensuscluster == i)
                                print(cluster[i]) 
                              }
```
# -----------------------------------------------------------MUTATIONS------------------------------------------------------------

We read the .maf file from http://firebrowse.org/?cohort=BRCA&download_dialog=true#
```{r}
raw_mut <- read.delim(file = "C:/Users/victo/OneDrive/Documentos/R/TNBC research/TNBC_research/BRCA-TP.final_analysis_set.maf", sep = "\t", header = T, stringsAsFactors = F)

class(raw_mut)
```
We check the data frame dimensions
```{r}
dim(raw_mut)
```
We can observe the type of mutation in the column "Variant_Classification"
```{r}
table(raw_mut$Variant_Classification)
```

We drop mutations related to: UTR, introns, RNA and silent.
```{r}
mut_filters <- c("3'UTR", "5'Flank", "5'UTR", "IGR", "Intron", "Silent", "RNA")
mut_filter_index <- which(raw_mut$Variant_Classification %in% mut_filters)
raw_mut <- raw_mut[-mut_filter_index,]
dim(raw_mut)
```
Obtenemos las distintas muestras y genes para hacer una matriz donde va a guardar 0 y 1 dependiendo si
hay presencia de la mutación.
```{r}
u_samples <- sort(unique(raw_mut$Tumor_Sample_Barcode))
u_genes <- sort(unique(raw_mut$Hugo_Symbol))
mut_matrix <- matrix(0, nrow=length(u_genes), ncol=length(u_samples),

dimnames = list(u_genes, u_samples))

mut_matrix[1:5, 1:5]

mut_matrix <- mut_matrix[,-1]

mut_matrix[1:5, 1:5]
```

Llenamos la matriz al hacer un ciclo por muestra
```{r}
for(i in colnames(mut_matrix)){
aux_genes <- raw_mut$Hugo_Symbol[which(raw_mut$Tumor_Sample_Barcode == i)]
mut_matrix[aux_genes, i] <- 1
}
```


We read the clinical information, each row is a clinical variable
```{r}
clinical <- read.delim(file = "BRCA.clin.merged.txt", sep = "\t",

stringsAsFactors = F, row.names=1)

dim(clinical)
```

To relate our genomic information with the clinical information, we detect the pattern "barcode"
```{r}
grep(pattern = "barcode", x = rownames(clinical))
```
```{r}
rownames(clinical)[10]
```
## CORRELACION RNASEQ - MUTATIONS
```{r}
colnames(mut_matrix)[1:5]
```

```{r}
colnames(raw_brca_rnaseq)[1:5]
```

```{r}
dim(mut_matrix)
```

```{r}
dim(raw_brca_rnaseq)
```
We observe the difference in the naming convention of mutations and rna-seq data, as well as the difference in dimensions. We can compare the first 16 characters.

```{r}
mut_rnaseq_match <- match(gsub(pattern = "-", replacement = "\\.",
x = substr(colnames(mut_matrix), 1, 16)),
substr(colnames(raw_brca_rnaseq), 1, 16))

mut_rnaseq_match
```
```{r}
# to store the NA values postitions
mut_rnaseq_match_NA <- which(is.na(mut_rnaseq_match))

# to remove the NA values from mut_matrix_rna and mut_rnaseq_match
mut_matrix_rna <- mut_matrix[,-mut_rnaseq_match_NA]
mut_rnaseq_match <- mut_rnaseq_match[-mut_rnaseq_match_NA]

# to store only the rna_seq values that match the mutations
rna_mut <- raw_brca_rnaseq[,mut_rnaseq_match]

cbind(colnames(mut_matrix_rna)[c(1,20,50,54)], colnames(rna_mut)[c(1,20,50,54)])
```
We filter the genes in RNA-seq that show no variation and we keep the most frequent mutations only.
```{r}
rna_mut_mad <- apply(rna_mut, 1, mad)
mad_zero <- which(rna_mut_mad == 0)
rna_mut <- rna_mut[-mad_zero,]
table(apply(mut_matrix_rna,1,sum))
```
```{r}
# We count the times each mutation appears in the matrix
mut_matrix_rna_count <- apply(mut_matrix_rna,1,sum)

# if the mutation count is greater than 9, we add it to the mut_matrix_rna
mut_matrix_rna <- mut_matrix_rna[which(mut_matrix_rna_count > 9),]
```

We run a t-test to know which genes change according to the mutations
```{r}

mut_rna_test <- c()
mut_rna_test_names <- c()
for(i in 1:nrow(mut_matrix_rna)){
#for(i in 1:2){
# we apply the function "function(x)" to each of the row values of rna_mut where each row value is x
aux_mut_test <- t(sapply(1:nrow(rna_mut), function(x) {

# mutation: the mutation row (presence or absence of mutation per gene sequence)
# exp: the gene row of the rna_mut matrix
aux_test <- t.test(formula=exp~mut, data=data.frame(mut=mut_matrix_rna[i,],
exp=rna_mut[x,]));

aux_test$p.value
}))

# appending each test into a vector
mut_rna_test <- c(mut_rna_test, aux_mut_test)
# appending each name into a vector
mut_rna_test_names <- c(mut_rna_test_names, paste(rownames(mut_matrix_rna)[i], rownames(rna_mut), sep="_"))

}

# we save the P values and FDR of each test
mut_rna_test <- cbind(mut_rna_test, p.adjust(mut_rna_test))
colnames(mut_rna_test) <- c("p_value", "fdr")
rownames(mut_rna_test) <- mut_rna_test_names

# we order the resulting matrix by P value
mut_rna_test <- mut_rna_test[order(mut_rna_test[,"p_value"]),]
mut_rna_test[1:5,]

```

# FROM HERE AND BELOW ARE THE LATEST MODIFICATIONS (DON'T MODIFY ABOVE THIS LINE) ---------------------------------------

##Fisher test with MUTATIONS cluster data

A row was added at the end of the RNAseq data (cluster_rna_mut) with the value of the cluster
```{r}

# Setting the RNA mut data frame with the consensusCluster information (last col)
cluster_rna_mut <- rbind(res$realdataresults[[2]][["ordered_data"]],
                     t(res$realdataresults[[2]][["ordered_annotation"]]))

# Checking which mutations barcodes match the rnaseq in the clusters
cluster_mut_rnaseq_match <- match(gsub(pattern = "-", replacement = "\\.",
x = substr(colnames(mut_matrix), 1, 16)),
substr(colnames(cluster_rna_mut), 1, 16))

# to store the NA values postitions
cluster_mut_rnaseq_match_NA <- which(is.na(cluster_mut_rnaseq_match))

# to remove the NA values from mut_matrix_rna and mut_rnaseq_match
cluster_mut_matrix_rna <- mut_matrix[,-cluster_mut_rnaseq_match_NA]
cluster_mut_rnaseq_match <- cluster_mut_rnaseq_match[-cluster_mut_rnaseq_match_NA]

# to store only the rna_seq values that match the mutations
cluster_rna_mut <- cluster_rna_mut[,cluster_mut_rnaseq_match]

```

```{r}
# We count the times each mutation appears in the matrix
cluster_mut_matrix_rna_count <- apply(cluster_mut_matrix_rna,1,sum)

# if the mutation count is greater than 9, we add it to the mut_matrix_rna

# **Q. When running the line with ">9" it only returns 3 values of mutations, is it okay or can we modify the frequency threshold as I did (to obtain more mutation values)?
#cluster_mut_matrix_rna <- cluster_mut_matrix_rna[which(cluster_mut_matrix_rna_count > 9),]
cluster_mut_matrix_rna <- cluster_mut_matrix_rna[which(cluster_mut_matrix_rna_count > 0),] # NOTA: en lugar del 9 buscar un porcentaje del total de muestras, por ejemplo 5%
```

```{r}
# Adding the cluster row to the cluster_mut_matrix_rna
cluster_row <- cluster_rna_mut[nrow(cluster_rna_mut),]
# Rename columns & rbind
colnames(cluster_row) <- colnames(cluster_mut_matrix_rna)
cluster_mut_matrix_rna <- rbind(cluster_mut_matrix_rna,
                          cluster_row)

```


# FISHER TEST PER MUTATION
```{r}
# transposing the matrix, to have genes as records and mutations + clusters as fields
cluster_mut_matrix_rna_t <- t(cluster_mut_matrix_rna)

## counting 1s and 0s per gene and per cluster
mut_fisher_test <- c()
mut_fisher_test_names <- c()

for(mut in 1:(ncol(cluster_mut_matrix_rna_t)-1)){
  # is the row cluster 1 or cluster 2
  cluster1_nomut <- length(which(cluster_mut_matrix_rna_t[,mut] == 0 & cluster_mut_matrix_rna_t[,ncol(cluster_mut_matrix_rna_t)] == 1))
  cluster2_nomut <- length(which(cluster_mut_matrix_rna_t[,mut] == 0 & cluster_mut_matrix_rna_t[,ncol(cluster_mut_matrix_rna_t)] == 2))
  cluster1_mut <- length(which(cluster_mut_matrix_rna_t[,mut] == 1 & cluster_mut_matrix_rna_t[,ncol(cluster_mut_matrix_rna_t)] == 1))
  cluster2_mut <- length(which(cluster_mut_matrix_rna_t[,mut] == 1 & cluster_mut_matrix_rna_t[,ncol(cluster_mut_matrix_rna_t)] == 2))
  
  df <- data.frame(cluster1=c(0,0), cluster2=c(0,0))
  
 
  df$cluster1 <- c(cluster1_nomut, cluster1_mut)
  df$cluster2 <- c(cluster2_nomut,cluster2_mut)
  
  f_test_var <- fisher.test(df)
  mut_fisher_test <- c(mut_fisher_test, f_test_var$p.value)
  # appending each name into a vector
  mut_fisher_test_names <- c(mut_fisher_test_names, paste(colnames(cluster_mut_matrix_rna_t)[mut]))
  
  #print(f_test_var$p.value)
}

  # we save the P values and FDR of each test
  mut_fisher_test <- cbind(mut_fisher_test, p.adjust(mut_fisher_test))
  colnames(mut_fisher_test) <- c("p_value", "fdr")
  rownames(mut_fisher_test) <- mut_fisher_test_names
  
  # we order the resulting matrix by P value
  mut_fisher_test <- mut_fisher_test[order(mut_fisher_test[,"p_value"]),]
  mut_fisher_test[1:10,]

```
# CHI SQUARED TEST PER MUTATION
```{r}
# transposing the matrix, to have genes as records and mutations + clusters as fields
cluster_mut_matrix_rna_t <- t(cluster_mut_matrix_rna)

## counting 1s and 0s per gene and per cluster
mut_chi_test <- c()
mut_chi_test_names <- c()

for(mut in 1:(ncol(cluster_mut_matrix_rna_t)-1)){
  # is the row cluster 1 or cluster 2
  cluster1_nomut <- length(which(cluster_mut_matrix_rna_t[,mut] == 0 & cluster_mut_matrix_rna_t[,ncol(cluster_mut_matrix_rna_t)] == 1))
  cluster2_nomut <- length(which(cluster_mut_matrix_rna_t[,mut] == 0 & cluster_mut_matrix_rna_t[,ncol(cluster_mut_matrix_rna_t)] == 2))
  cluster1_mut <- length(which(cluster_mut_matrix_rna_t[,mut] == 1 & cluster_mut_matrix_rna_t[,ncol(cluster_mut_matrix_rna_t)] == 1))
  cluster2_mut <- length(which(cluster_mut_matrix_rna_t[,mut] == 1 & cluster_mut_matrix_rna_t[,ncol(cluster_mut_matrix_rna_t)] == 2))
  
  df <- data.frame(cluster1=c(0,0), cluster2=c(0,0))
  
 
  df$cluster1 <- c(cluster1_nomut, cluster1_mut)
  df$cluster2 <- c(cluster2_nomut,cluster2_mut)
  
  chi_test_var <- chisq.test(df, simulate.p.value = TRUE)
  mut_chi_test <- c(mut_chi_test, chi_test_var$p.value)
  # appending each name into a vector
  mut_chi_test_names <- c(mut_chi_test_names, paste(colnames(cluster_mut_matrix_rna_t)[mut]))
  
  #print(f_test_var$p.value)
}

  # we save the P values and FDR of each test
  mut_chi_test <- cbind(mut_chi_test, p.adjust(mut_chi_test))
  colnames(mut_chi_test) <- c("p_value", "fdr")
  rownames(mut_chi_test) <- mut_chi_test_names
  
  # we order the resulting matrix by P value
  mut_chi_test <- mut_chi_test[order(mut_chi_test[,"p_value"]),]
  mut_chi_test[1:5,]

```

# T TEST PER GENE
```{r}
# transposing the matrix, to have genes as records and mutations + clusters as fields
cluster_mut_matrix_rna_t <- t(cluster_mut_matrix_rna)

## counting 1s and 0s per gene and per cluster
mut_t_test <- c()
mut_t_test_names <- c()

for(gene in 1:nrow(cluster_mut_matrix_rna_t)){
  # is the row cluster 1 or cluster 2
  cluster1_nomut <- length(which(cluster_mut_matrix_rna_t[gene,] == 0 & cluster_mut_matrix_rna_t[gene,ncol(cluster_mut_matrix_rna_t)] == 1))
  cluster2_nomut <- length(which(cluster_mut_matrix_rna_t[gene,] == 0 & cluster_mut_matrix_rna_t[gene,ncol(cluster_mut_matrix_rna_t)] == 2))
  cluster1_mut <- length(which(cluster_mut_matrix_rna_t[gene,] == 1 & cluster_mut_matrix_rna_t[gene,ncol(cluster_mut_matrix_rna_t)] == 1))
  cluster2_mut <- length(which(cluster_mut_matrix_rna_t[gene,] == 1 & cluster_mut_matrix_rna_t[gene,ncol(cluster_mut_matrix_rna_t)] == 2))
  
  df <- data.frame(cluster1=c(0,0), cluster2=c(0,0))
  
 
  df$cluster1 <- c(cluster1_nomut, cluster1_mut)
  df$cluster2 <- c(cluster2_nomut,cluster2_mut)
  
  t_test_var <- t.test(df)
  mut_t_test <- c(mut_t_test, t_test_var$p.value)
  # appending each name into a vector
  mut_t_test_names <- c(mut_t_test_names, paste(rownames(cluster_mut_matrix_rna_t)[gene]))
  
  #print(f_test_var$p.value)
}

  # we save the P values and FDR of each test
  mut_t_test <- cbind(mut_t_test, p.adjust(mut_t_test))
  colnames(mut_t_test) <- c("p_value", "fdr")
  rownames(mut_t_test) <- mut_t_test_names
  
  # we order the resulting matrix by P value
  mut_t_test <- mut_t_test[order(mut_t_test[,"p_value"]),]
  mut_t_test[1:5,]

```


# T TEST PER GENE
```{r}
# transposing the matrix, to have genes as records and mutations + clusters as fields
cluster_mut_matrix_rna_t <- t(cluster_mut_matrix_rna)

## counting 1s and 0s per gene and per cluster

for(gene in 1:nrow(cluster_mut_matrix_rna_t)){
  # is the row cluster 1 or cluster 2
  gene_cluster <- as.numeric(cluster_mut_matrix_rna_t[gene,ncol(cluster_mut_matrix_rna_t)])
  mutations_ct <- length(which(cluster_mut_matrix_rna_t[gene,-ncol(cluster_mut_matrix_rna_t)] == 1))
  notmutations_ct <- length(which(cluster_mut_matrix_rna_t[gene,-ncol(cluster_mut_matrix_rna_t)] == 0))
  
  df <- data.frame(cluster1=c(0,0), cluster2=c(0,0))
  
  if(gene_cluster == 1){
    df$cluster1 <- c(mutations_ct, notmutations_ct)
    df$cluster2 <- c(0,0)
  }else{
    df$cluster2 <- c(mutations_ct, notmutations_ct)
    df$cluster1 <- c(0,0)
  }
  
  t_test_var <- t.test(df)
  print(t_test_var$p.value)
}

# checking what this function does:
#apply(mat, 1, function(x) t.test(x[which(cluster ==1)], x[which(cluster == 2)]))

```

# TODO: Fisher test and contigency tables from cluster_mut_matrix_rna

We run a t-test to know which genes change according to the mutations
```{r}

cluster_mut_rna_test <- c()
cluster_mut_rna_test_names <- c()

cluster_rna_mut <- as.matrix(cluster_rna_mut[-c(nrow(cluster_rna_mut)),])

for(i in 1:nrow(cluster_mut_matrix_rna)){
  
# we apply the function "function(x)" to each of the row values of rna_mut where each row value is x
cluster_aux_mut_test <- t(sapply(1:nrow(cluster_rna_mut), function(x) {

# mutation: the mutation row (presence or absence of mutation per gene sequence)
# exp: the gene row of the rna_mut matrix
cluster_aux_test <- t.test(formula=exp~mut, data=data.frame(mut=cluster_mut_matrix_rna[i,],exp=cluster_rna_mut[x,]));

cluster_aux_test$p.value
}))

# appending each test into a vector
cluster_mut_rna_test <- c(cluster_mut_rna_test, 
                          cluster_aux_mut_test)
# appending each name into a vector
cluster_mut_rna_test_names <- c(cluster_mut_rna_test_names,
                                paste(rownames(cluster_mut_matrix_rna)[i],
                                rownames(cluster_rna_mut), sep="_"))

}

# we save the P values and FDR of each test
cluster_mut_rna_test <- cbind(cluster_mut_rna_test, p.adjust(cluster_mut_rna_test))
colnames(cluster_mut_rna_test) <- c("p_value", "fdr")
rownames(cluster_mut_rna_test) <- cluster_mut_rna_test_names

# we order the resulting matrix by P value
cluster_mut_rna_test <- cluster_mut_rna_test[order(cluster_mut_rna_test[,"p_value"]),]
cluster_mut_rna_test[1:5,]

```
## TODO: Check the source of mistake above



# Cluster-Mutation relationships -----------------------------------------------------

Cluster 1
```{r}
# Select the cluster number
k_num <- 1 

# Map the cluster clinical ID
mapped_id_cluster <- gsub(pattern = "-", replacement = "\\.",x = substr(rownames(cluster[[k_num]]), 1, 16))
temp <- mut_matrix_rna

# If the mutations' patient IDs are in the clusters' patient IDs, we keep them, otherwise we drop
for (element_i in 1:length(colnames(temp))){
  id_mut <- colnames(temp)[element_i]
  mapped_id_mut <- gsub(pattern = "-", replacement = "\\.",x = substr(id_mut, 1, 16))

  if (mapped_id_mut %in% mapped_id_cluster)
    temp<-temp
  else
    temp <- subset(temp, select = -c(element_i))
}

# We assign the mutation information to the cluster matrix
cluster1_mut<- temp

```

Cluster 2
```{r}
# Select the cluster number
k_num <- 2

# Map the cluster clinical ID
mapped_id_cluster <- gsub(pattern = "-", replacement = "\\.",x = substr(rownames(cluster[[k_num]]), 1, 16))
temp <- mut_matrix_rna

# If the mutations' patient IDs are in the clusters' patient IDs, we keep them, otherwise we drop
for (element_i in 1:length(colnames(temp))){
  id_mut <- colnames(temp)[element_i]
  mapped_id_mut <- gsub(pattern = "-", replacement = "\\.",x = substr(id_mut, 1, 16))

  if (mapped_id_mut %in% mapped_id_cluster)
    temp<-temp
  else
    temp <- subset(temp, select = -c(element_i))
}

# We assign the mutation information to the cluster matrix
cluster2_mut<- temp

```

Count of mutations per cluster
```{r}
# Cluster 1
 cluster1_mut_rna_count <- apply(cluster1_mut,1,sum)
# in percentage
 cluster1_mut_rna_p <- cluster1_mut_rna_count/sum(cluster1_mut_rna_count)


# Cluster 2
 cluster2_mut_rna_count <- apply(cluster2_mut,1,sum)
# in percentage
 cluster2_mut_rna_p <- cluster2_mut_rna_count/sum(cluster2_mut_rna_count)
```

Plotting the most relevant mutations

```{r}
# cluster 1
cluster1_df <- as.data.frame(cluster1_mut_rna_p[which(cluster1_mut_rna_p > 0.003)])

p<- ggplot(data=cluster1_df, 
         aes(x=rownames(cluster1_df), y=as.factor(apply(cluster1_df,1,as.character)))) + 
         geom_bar(stat="identity")
```

```{r}
# cluster 2
cluster2_df <- as.data.frame(cluster2_mut_rna_p[which(cluster2_mut_rna_p > 0.003)])
ggplotly(
  ggplot(data=cluster2_df, 
         aes(x=rownames(cluster2_df), y=as.factor(apply(cluster2_df,1,as.character)))) + 
         geom_bar(stat="identity")
)
```
#TODO: create a dataframe with the fields: cluster, ID, mut_count (to make the fisher test)


```{r}
# Clusters df
clusters_df <- rbind(cluster[[1]],cluster[[2]])

# empty df
df <- list()
df_col <- list()

rna_mut_selected <- list()
rna_mut_selected_names<- list()
rna_mut_copy <-rna_mut

# Map the cluster clinical ID
mapped_id_cluster <- gsub(pattern = "-", replacement = "\\.",x = substr(rownames(clusters_df), 1, 16))
rownames(clusters_df) <- mapped_id_cluster

temp <- mut_matrix_rna

mapped_id_rnamut <- gsub(pattern = "-", replacement = "\\.",x = substr(colnames(rna_mut_copy), 1, 16))
colnames(rna_mut_copy) <- mapped_id_rnamut

# If the mutations' patient IDs are in the clusters' patient IDs, we keep them, otherwise we drop
counter<-0
for (element_i in 1:length(colnames(temp))){
  id_mut <- colnames(temp)[element_i]
  mapped_id_mut <- gsub(pattern = "-", replacement = "\\.",x = substr(id_mut, 1, 16))

  if (mapped_id_mut %in% mapped_id_cluster){
    counter<-counter+1
  
    df[[counter]] <- temp[,id_mut]
    df_col[[counter]] <- clusters_df[mapped_id_mut,]
    
    rna_mut_selected[[counter]]<- rna_mut_copy[,mapped_id_mut]
    rna_mut_selected_names[[counter]]<-clusters_df[mapped_id_mut,]
}
}

# We arrange the resulting lists into a matrix
clusters_mut_matrix<- do.call(cbind, df)
clusters_mut_matrix_names<-do.call(cbind, df_col)

rna_mut_matrix <- do.call(cbind, rna_mut_selected)
rna_mut_matrix_names <- do.call(cbind, rna_mut_selected_names)

# we save it as a data frame and assign the cluster number as column name
clusters_mut<-as.data.frame(clusters_mut_matrix)
colnames(clusters_mut)<-clusters_mut_matrix_names

rna_mut_selected<-as.data.frame(rna_mut_matrix)
colnames(rna_mut_selected)<-rna_mut_matrix_names

```

## Mutation count per cluster
```{r}
# Mutations in cluster 1
clus1 <- clusters_mut[,which(colnames(clusters_mut)==1)]
clus_count1 <- rowSums(clus1)


# Mutations in cluster 2
clus2 <- clusters_mut[,which(colnames(clusters_mut)==2)]
clus_count2 <- rowSums(clus2)

# Binding both clusters
clusters_mut_counts <- rbind(clus_count1,clus_count2)
```


## Fisher test count all cluster data
```{r}
f_test <-fisher.test(clusters_mut_counts, simulate.p.value = TRUE)

f_test$p.value
```

## contingency table per mutation
```{r}
c<-0
mut_names <- c()

for (n in 1:length(clus_count1)){
cont <- rbind(c(clus_count1[n],sum(clus_count1[-n])),c(clus_count2[n],sum(clus_count2[-n])))
cont_ftest <- fisher.test(cont) 
cont_pvalue <- cont_ftest$p.value

if(cont_pvalue < 0.05){
  c<-c+1
  
  print(c(names(clus_count1[n]), cont_pvalue))
  mut_names[c] <- names(clus_count1[n])
}
}
```


```{r}

mut_rna_test <- c()
mut_rna_test_names <- c()
#for(i in 1:nrow(mut_matrix_rna)){
for(i in 1:2){
aux_mut_test <- t(sapply(1:nrow(rna_mut), function(x) {

aux_test <- t.test(formula=exp~mut, data=data.frame(mut=mut_matrix_rna[i,],
exp=rna_mut[x,]));

aux_test$p.value
}))

mut_rna_test <- c(mut_rna_test, aux_mut_test)
mut_rna_test_names <- c(mut_rna_test_names,

paste(rownames(mut_matrix_rna)[i], rownames(rna_mut), sep="_"))

}
mut_rna_test <- cbind(mut_rna_test, p.adjust(mut_rna_test))
colnames(mut_rna_test) <- c("p_value", "fdr")
rownames(mut_rna_test) <- mut_rna_test_names
mut_rna_test <- mut_rna_test[order(mut_rna_test[,"p_value"]),]
mut_rna_test[1:5,]

```




# ------------------------------------------------Clustering analysis with mutation information----------------------------------
# Data Analysis of BRCA TNBC TCGA


## Data Pre-processing-----------------------------------------------------------------------------------------------------------

We avoid strings being recognized as factors
```{r}
options(stringsAsFactors = F)
```

Reading clinical data
```{r}
raw_brca_clin <- read.delim(file = "BRCA.clin.merged.txt", sep = "\t", header = F,
row.names = 1, as.is = T)
```


Obtaining the data for the 3 receptors (by visually recognizing the rows in the dataset)
```{r}
receptor_rows <- c(24,29,1160) # we may need to change the values of the receptor rows according to each specific dataset

print(rownames(raw_brca_clin)[receptor_rows])
```
Index of triple negative (TN) samples 
```{r}
index_TN <- which(as.character(raw_brca_clin[receptor_rows[1],]) == "negative" &
as.character(raw_brca_clin[receptor_rows[2],]) == "negative" &
as.character(raw_brca_clin[receptor_rows[3],]) == "negative")
```

Filtering to obtain only Triple Negative data and obtain the key of the samples (patient barcodes)
```{r}
brca_clin <- raw_brca_clin[,index_TN]
tn_samples <- toupper(as.character(brca_clin[21,])) # patient barcode row
```

Reading Mutation data
```{r}
f <- raw_mut
raw_brca_rnaseq <- data.matrix(brca_rnaseq[-1,])
```

Extracting gene symbols
```{r}
gene_symbols <- as.character(sapply(rownames(raw_brca_rnaseq), function(x)
unlist(strsplit(x = x, split = "\\|"))[1]))
```

Drop rows with a gene symbol equal to “?”
```{r}
brca_rnaseq <- raw_brca_rnaseq[which(gene_symbols != "?"),]
gene_symbols <- gene_symbols[which(gene_symbols != "?")]
```

Observe the type of sample according to the TCGA barcode and delete the normal (type "11") https://docs.gdc.
cancer.gov/Encyclopedia/pages/TCGA_Barcode/
```{r}
sample_type <- substr(x = colnames(brca_rnaseq), start = 14, stop = 15)
brca_rnaseq <- brca_rnaseq[,-which(sample_type == "11")]
sample_type <- sample_type[-which(sample_type == "11")]
```

Match between TN samples (clinical) and RNAseq data
```{r}
brca_rnaseq_t <- t(mut_matrix_rna) # Transpose of Rnaseq 
```

## --------------------------------------------------Fisher test------------------------------------------------------------------
The fisher test helps us to understand whether there exists a significant non-random relationship among categorical variables or not. It is applied on contingency tables because these tables are used to represent the frequency for categorical variables and we can apply it on a matrix as well as matrices have the similar form. In R, we can use fisher.test function to perform the fisher test.

The hypotheses of the Fisher’s exact test are the same than for the Chi-square test, that is:

- Ho: the variables are independent, there is no relationship between the two categorical variables. Knowing the value of one variable does not help to predict the value of the other variable
- H1: the variables are dependent, there is a relationship between the two categorical variables. Knowing the value of one variable helps to predict the value of the other variable


# Creating the contingency matrix ----------

### NOTE: the code below wasn't saved on the last session, I could recover it via .Rhistory and .Rproj.user, I'll format it later on today, but jsut for reference it's added below.

# For the not present mutations (0) and the present mutations (1)
```{r}
library("imputeTS")

present_absent_count_df = data.frame()
present_absent_percentage_df = data.frame()

# for each mutation in the mutations matrix (ID and mutation)
for (i in 1:nrow(data.frame(mut_matrix_rna))){
#for (i in 1:5){
  # name of the current row
  row_name <- row.names(data.frame(mut_matrix_rna)[i,0])
 
  # we save the count of not present mutations 
  mut_not_present <- na_replace(data.frame(table(mut_matrix_rna[i,]))['1','Freq'],0)
  # we save the count of present mutations
  mut_present <- na_replace(data.frame(table(mut_matrix_rna[i,]))['2','Freq'],0)
  
  # matrix with present and absent counts per mutation
  present_absent_count_df[i,1:2] <- data.frame("present"=c(mut_present), 
                                               "absent"=c(mut_not_present), 
                                               row.names = row_name)
  # matrix with present and absent counts per mutation
  present_absent_percentage_df[i,1:2] <- data.frame("present"=c(mut_present/ncol(mut_matrix_rna)), 
                                                    "absent"=c(mut_not_present/ncol(mut_matrix_rna)), 
                                                    row.names = row_name)
}

mut_f_test <- fisher.test(present_absent_count_df, simulate.p.value = TRUE)

```

```{r}
mut_f_test
```


```{r}
# Present in cluster 1

# Reading clinical data
mut_rnaseq_match1 <- match(gsub(pattern = "-", replacement = "\\.", x = substr(colnames(mut_matrix), 1, 16)), substr(row.names(cluster[[1]]), 1, 16))

mut_rnaseq_match1

mut_rnaseq_match_NA <- which(is.na(mut_rnaseq_match1))
mut_matrix_rna <- mut_matrix[,-mut_rnaseq_match_NA]
mut_rnaseq_match1 <- mut_rnaseq_match1[-mut_rnaseq_match_NA]
rna_mut <- row.names(cluster[[1]])[mut_rnaseq_match1]

cbind(colnames(mut_matrix_rna)[c(1,20,50,54)], rna_mut[c(1,20,50,54)])

mut_matrix_rna_count <- apply(mut_matrix_rna,1,sum)
mut_matrix_rna <- mut_matrix_rna[which(mut_matrix_rna_count > 9),]

present_absent_count_df1 = data.frame()
present_absent_percentage_df1 = data.frame()

for (i in 1:nrow(data.frame(mut_matrix_rna))){
#for (i in 1:5){
  row_name <- row.names(data.frame(mut_matrix_rna)[[i]])
  mut_not_present <- na_replace(data.frame(table(mut_matrix_rna[i]))['1','Freq'],0)
  mut_present <- na_replace(data.frame(table(mut_matrix_rna[i]))['2','Freq'],0)
  
  present_absent_count_df1[i,1:2] <- data.frame("present"=c(mut_present), 
                                               "absent"=c(mut_not_present), 
                                               row.names = row_name)
  present_absent_percentage_df1[i,1:2] <- data.frame("present"=c(mut_present/ncol(mut_matrix_rna)), 
                                                    "absent"=c(mut_not_present/ncol(mut_matrix_rna)), 
                                                    row.names = row_name)
}

```








