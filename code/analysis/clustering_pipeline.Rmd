---
title: "TNBC Clustering (Gene expression, mutations, clinical data)"
author: "Victoria Rios"
date: "30/08/2022"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Data Analysis of TNBC gene expression information and mutations

***

## Data Importing

Avoid strings being recognized as factors and import libraries used in the next chunks of code.
```{r}
options(stringsAsFactors = F)

library(factoextra)
library(M3C)
library(plyr)
```

### Expression data

Import resulting dataframes containing gene expression data (previously normalized with log2 and batch effect assessed by ComBat), where each column is a sample and each row a gene.

characteristic      | train | train_mad 
rows (genes)        | 10856 | 2648   
columns (samples)   | 509   | 509

```{r}
# Read the csv files containing the dataframes
train <-
  read.csv("~/TNBC_Research/code/csv_and_objects/ComBat/ComBat.csv",
           row.names = "row.names")
train_mad <-
  read.csv("~/TNBC_Research/code/csv_and_objects/ComBat/ComBat_mad.csv",
           row.names = "row.names")
```

Observe the first records of the gene expression dataframe
```{r}
head(train_mad)
```


### Clinical data

Import the clinical information dataframe that matches with the samples found in the genetic information dataframe imported in the previous chunks of code (specifically "train_mad" dataframe).
```{r}
# Read the csv file with the clinical information
RNA_clin_data <-
  read.csv(
    "~/TNBC_Research/code/csv_and_objects/ComBat/clinical_data_combat_mad.csv",
    row.names = "row.names"
  )
```

Observe the first records of the clinical information dataframe
```{r}
head(RNA_clin_data)
```

We verify the shape of all of the imported dataframes.
```{r}
library(glue)

glue("Train -> rows(genes): {nrow(train)}, columns(samples): {ncol(train)}")
glue("Train_mad -> rows(genes): {nrow(train_mad)}, columns(samples): {ncol(train_mad)}")
glue("RNA_clin_data -> rows(samples): {nrow(RNA_clin_data)}, columns(clinical variables): {ncol(RNA_clin_data)}")
```

***

## Data Engineering

It is needed to perform feature engineering, specially on the categorical clinical features, since some of the classes are correlated or even duplicated among the set of unique labels per feature. A manual renaming of the classes is performed to account for this issue.

Categorical features to preprocess: 
- Histological type (histological_type)
- Histological grade (histological_grade)
- Race (race)
- Age (age)
- Age at menarche (age_at_menarche)
- Tumor size mm (tumor_size_mm)
- Survival time (days_to_last_followup)

```{r}
# Define a vector with the names of the features to engineer
features_to_engineer <- c("histological_type",
                          "histological_grade",
                          "race",
                          "age",
                          "age_at_menarche",
                          "tumor_size_mm",
                          "days_to_last_followup")

# Define a loop to go over each feature and make the classes compliant
for (feature in features_to_engineer) {
  
  # Display the unique values of the raw features
  print(unique(RNA_clin_data[feature]))
  
  if (feature == "histological_type") {
    RNA_clin_data$histological_type <-
      mapvalues(RNA_clin_data$histological_type,
                c("Mixed (not specified)"),
                c("Mixed"))
  } else if (feature == "histological_grade") {
    RNA_clin_data$histological_grade <-
      mapvalues(
        RNA_clin_data$histological_grade,
        c(
          "UNKNOWN",
          "N/A",
          "Unknown",
          "II-III",
          "I LOW GRADE (WELL DIFFERENTIATED)"
        ),
        c(NA, NA, NA, "2", "1")
      )
  } else if (feature == "race") {
    RNA_clin_data$race <-
      mapvalues(
        RNA_clin_data$race,
        c(
          "W",
          "B",
          "H",
          "UNKNOWN",
          "WHITE",
          "BLACK OR AFRICAN AMERICAN",
          "OTHER"
        ),
        c(
          "white",
          "african american",
          "hispanic or latino",
          NA,
          "white",
          "african american",
          NA
        )
      )
  } else if (feature == "age") {
    
    RNA_clin_data$age <- as.numeric(RNA_clin_data$age)
    
    RNA_clin_data$age_label <- RNA_clin_data$age
    
    print(hist(RNA_clin_data$age))
    
    for (age_row in 1:nrow(RNA_clin_data)) {
      if (is.na(RNA_clin_data[age_row, "age"]) == FALSE) {
        if (RNA_clin_data[age_row, "age"] < 40) {
          RNA_clin_data[age_row, "age_label"] <- "30s"
        }
        if (RNA_clin_data[age_row, "age"] >= 40 &
            RNA_clin_data[age_row, "age"] < 50) {
          RNA_clin_data[age_row, "age_label"] <- "40s"
        }
        if (RNA_clin_data[age_row, "age"] >= 50 &
            RNA_clin_data[age_row, "age"] < 60) {
          RNA_clin_data[age_row, "age_label"] <- "50s"
        }
        if (RNA_clin_data[age_row, "age"] >= 60 &
            RNA_clin_data[age_row, "age"] < 70) {
          RNA_clin_data[age_row, "age_label"] <- "60s"
        }
        if (RNA_clin_data[age_row, "age"] >= 70 &
            RNA_clin_data[age_row, "age"] < 80) {
          RNA_clin_data[age_row, "age_label"] <- "70s"
        }
        if (RNA_clin_data[age_row, "age"] >= 80 &
            RNA_clin_data[age_row, "age"] < 90) {
          RNA_clin_data[age_row, "age_label"] <- "80s"
        }
        if (RNA_clin_data[age_row, "age"] >= 90) {
          RNA_clin_data[age_row, "age_label"] <- "90s"
        }
      }
    }
  } else if (feature == "tumor_size_mm") {
    
    RNA_clin_data$tumor_size_mm <- as.numeric(RNA_clin_data$tumor_size_mm)
    
    RNA_clin_data$tumor_size <- RNA_clin_data$tumor_size_mm
    
    print(hist(RNA_clin_data$tumor_size_mm))
    
    for (age_row in 1:nrow(RNA_clin_data)) {
      if (is.na(RNA_clin_data[age_row, "tumor_size_mm"]) == FALSE) {
        if (RNA_clin_data[age_row, "tumor_size_mm"] < 10) {
          RNA_clin_data[age_row, "tumor_size"] <- "Below 10 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 10 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 20) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 10 and 19 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 20 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 30) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 20 and 29 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 30 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 40) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 30 and 39 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 40 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 50) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 40 and 49 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 50 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 60) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 50 and 59 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 60 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 70) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 60 and 69 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 70 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 80) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 70 and 79 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 80 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 90) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 80 and 89 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 90) {
          RNA_clin_data[age_row, "tumor_size"] <- "Greater than 89 mm"
        }
      }
    }
    
  } else if (feature == "days_to_last_followup") {
    RNA_clin_data$Surv_event <- NA
    RNA_clin_data$Surv_months <- NA
    RNA_clin_data$Surv_days <- NA
    
    for (i in 1:nrow(RNA_clin_data)) {
      if (is.na(RNA_clin_data$days_to_last_followup[i]) != T) {
        RNA_clin_data$Surv_months[i] <-
          RNA_clin_data$days_to_last_followup[i] / 30
        RNA_clin_data$Surv_days[i] <-
          RNA_clin_data$days_to_last_followup[i]
      }
      if (is.na(RNA_clin_data$survival_months[i]) != T) {
        RNA_clin_data$Surv_months[i] <- RNA_clin_data$survival_months[i]
        RNA_clin_data$Surv_days[i] <-
          RNA_clin_data$survival_months[i] * 30
      }
      if (isTRUE(is.na(RNA_clin_data$vital_status[i]) != T) &
          RNA_clin_data$vital_status[i] %in% c("alive", "Living")) {
        RNA_clin_data$Surv_event[i] <- 0
      }
      if (isTRUE(is.na(RNA_clin_data$vital_status[i]) != T) &
          RNA_clin_data$vital_status[i] %in% c("dead", "Died of Disease") == T) {
        RNA_clin_data$Surv_event[i] <- 1
      }
    }
  }
  
  # Display the unique values of the engineered features
  print(unique(RNA_clin_data[feature]))
}

```

***

## Dimensionality reduction

There is a great need to develop analytical methodology to analyze and to exploit the information contained in gene expression data. Because of the large number of genes and the complexity of biological networks, clustering is a useful exploratory technique for analysis of gene expression data. Prior starting the clustering process, principal component analysis (PCA) is needed to reduce the dimensionality of our large and complex data set and allow us to explain the data in a matrix of fewer dimensions (more manageable and memory efficient).

**Principal components analysis (PCA)**
To compute a PCA in R we can use the prcomp() function. This function takes a matrix of data, where the columns are the variables that we want to use to transform our samples, which should be the rows of the matrix.

In our case, we want to look for similarities across our patients (samples = rows) based on gene expression (variables = columns). For that reason, we need to provide a transposed version of our table to the prcomp() function:
```{r}
t(train_mad)[1:10,1:10]
```

Pass the transposed gene dataframe to the prcomp() function, so each row represents a sample and each column a gene.
```{r}
# Principal components analysis
x_train <- prcomp(t(train_mad), scale = T)
```

Visualize eigenvalues (scree plot) to show the percentage of variances explained by each principal component. We target to keep ~75-85% of the variance from the original dataset.
```{r}
scree_plot <- fviz_eig(x_train, addlabels=TRUE)
scree_plot
```
As seen in the plot, we are not able to get the desired variance percentage even after adding up the first 2 components, therefore, more than 2 components are used for model training. On the other side, only two components are used to visualize the data points in a reader-friendly manner.


**Graph of individuals**
We plot to visualize the results of the dimensionality reduction technique on the gene expression data.
```{r}
# train
fviz_pca_ind(
  x_train,
  col.ind = "cos2",
  # Color by the quality of representation
  gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
  repel = T,
  # Avoid text overlapping,
  max.overlaps = Inf
)
```

Visual verification of the differences across different components
```{r}
vals_to_check <- as.factor(RNA_clin_data$race)

# PC1 vs PC2
plot(
  x_train$rotation[, 1],
  x_train$rotation[, 2],
  xlab = "PCA component 1",
  ylab = "PCA component 2",
  col = vals_to_check
)

# PC3 vs PC4
plot(
  x_train$rotation[, 3],
  x_train$rotation[, 4],
  xlab = "PCA component 3",
  ylab = "PCA component 4",
  col = vals_to_check
)

# PC5 vs PC6
plot(
  x_train$rotation[, 5],
  x_train$rotation[, 6],
  xlab = "PCA component 5",
  ylab = "PCA component 6",
  col = vals_to_check
)
```
We can see that there isn't an apparent difference in the data explained by the first 6 components with the highest explained variance, so, we'll proceed with the analysis with a visualization focused on the first two PCs.

***

## Consensus Clustering

**Extract taken from the M3C package documentation (https://rdrr.io/bioc/M3C/f/vignettes/M3Cvignette.Rmd)**

Genome-wide expression data is used to stratify patients into classes using clustering algorithms for precision medicine. The Monti consensus clustering algorithm (Monti et al., 2003) is a widely applied method to identify the number of clusters (K) through the principle of stability selection. This algorithm works by resampling and clustering the data for each K and a NXN consensus matrix is calculated, where each element represents the fraction of times two samples clustered together. A perfectly stable matrix would consist entirely of 0s and 1s, representing all sample pairs always clustering together or not together over resampling iterations. 

The next step is to compare the stability of these consensus matrices to decide K. The Proportion of Ambiguous Clustering (PAC) score (Senbabaoglu et al., 2014) has been proposed to assess consensus matrix stability for each K, however, it has bias towards greater values of K. This is due to a general problem with this type of consensus clustering algorithm that occurs because as K increases the consensus matrix converges towards a matrix of perfect stability simply by chance. The alternative well used delta K metric to find K is subjective as it relies on finding an elbow point and has been demonstrated to be inferior to the PAC score. 

Monte Carlo reference-based consensus clustering (M3C) (John et al., 2018) was made to solve these problems by comparing the real stability scores with those expected under a random model. M3C uses a Monte Carlo simulation to generate null distributions of stability scores along the range of K which, by comparing with the real stability scores, are used to decide the optimal K and reject the null hypothesis K=1.

Choose the number of components that will represent ~85% of the variance of the data
```{r}
# Define a variable with the PCs to keep
PCs_to_keep = 285

# Print the cumulative variance of a range of PCs
summary(x_train)$importance[3, 1:PCs_to_keep][PCs_to_keep]
```

Perform consensus clustering on the normalized data
```{r}
library(dplyr)

# Change gene expression data type to numeric
x_train[["x"]] <-
  mutate_all(as.data.frame(x_train[["x"]]), function(x)
    as.numeric(as.character(x)))

# Pass the gene expression data frame to perform consensus clustering
# Where each row is a PC and each column is a sample.
res_train <- M3C(
  t(x_train[["x"]][, 1:PCs_to_keep]),
  removeplots = TRUE,
  iters = 50,
  fsize = 8,
  lthick = 1,
  dotsize = 1.25
)

optimal_k_pac_train = max(res_train[["assignments"]])

```

(Optional) Save the result of consensus clustering for later
```{r}
## Uncomment to save the result object to a local file
#saveRDS(res_train,
#        file = "~/TNBC_Research/code/csv_and_objects/clustering/consensus_clustering_res_final.rds")
# Restore the object
#res_train <- readRDS(file = "~/TNBC_Research/code/csv_and_objects/clustering/consensus_clustering_res_final.rds")
```

### Check the scores

The scores and p values are contained within the res$scores object. We can see below the RCSI reaches a maxima at K = 3, the p_score supports this optimal K decision. This means the null hypothesis that K = 1 can be rejected for this dataset because we have achieved significance (alpha=0.05) versus a dataset with no clusters.

```{r}
# train
res_train$scores
```

### Visualizing the consensus clustering plots

1. CDF Plot

In the CDF and following PAC plot we can see the inherant bias of consensus clustering where as K increases so does the apparent stability of the results (or CDF plot flatness), this we correct for by using a reference. This makes the method more sensitive to detection of the underlying structure in noisy data.

```{r}
res_train$plots[[1]]
```

2. PAC Score

This figure below shows the PAC score, we can see an elbow at K = 3 which is suggestive this is the best K. However, the bias of consensus clustering can be seen here as the PAC score naturally tends towards lower values as K increases (see above plot), making selecting K without taking this into account subject to bias. Selecting the minimal PAC score will only work when the clusters are very well seperated.

```{r}
res_train$plots[[2]]
```

3. Relative Cluster Stability Index (RCSI)

The Relative Cluster Stability Index (RCSI) was derived and associated 95% confidence intervals which take into account the reference PAC scores using the reference mean. This metric is better than the PAC score for deciding class number, where the maximum value corresponds to the optimal K. In this example the RCSI has an optima at K=3. Either the RCSI or p scores can be used to select K, in the Bioinformatics paper we used M3C with the p values to select K 

```{r}
res_train$plots[[4]]
```

4. P score

Finally, we calculate a p score from the distribution, here we display the p scores from the beta distribution. If none of the p scores reach significance over a reasonable range of K (e.g. 10), then we accept the null hypothesis. In the GBM dataset, we can see K = 3 reaches signficance with an alpha of 0.05, therefore we can reject the null hypothesis K=1 for the GBM dataset.
```{r}
res_train$plots[[3]]
```

### Entropy objective function

There is another method to find the ideal K value based on a different evaluation criteria (entropy, instead of the previously used 'PAC'). We use information entropy and aim to minimize it to find K, where lower values correspond to less uncertainty in the system (more stability during sampling). Whilst this function often gives pretty similar results to the PAC score, it makes better theoretical sense because it does not rely on a subjective window, neither does it rely on calculating a CDF first and a metric from this CDF second.
```{r}
res_entropy_train <- M3C(
  t(x_train[["x"]][,1:PCs_to_keep]),
  method = 2,
  fsize = 8,
  lthick = 1,
  dotsize = 1.25,
  removeplots = TRUE,
  objective = 'entropy'
)

optimal_k_entropy_train = max(res_entropy_train$assignments)
```

Observing the results of the consensus clustering plots
```{r}
res_entropy_train$plots[[2]]
```

Comparing both consensus clustering methods optimal K
```{r}
if (optimal_k_pac_train == optimal_k_entropy_train) {
  
  print(paste0(
    "The optimal k clusters value is: ",
    as.character(optimal_k_pac_train)
  ))
}
```

Now we are pretty convinced there are 2 clusters within this data set which are not likely simply to have
occurred by chance alone. We can turn to examine the output objects that M3C generates.


### Understanding M3C Outputs

The 3 lines below extract the ordered (according in clustering results) expression data and the ordered annotation data from the results object after running M3C for a 2 cluster solution. We then take a look at the annotation object M3C outputs, a consensus cluster column has been added by M3C.

We gather the RNA-seq data and clinical data from the clustering results as different variables
```{r}
# RNA-seq data and cluster annotation
RNA_seq_data <-
  res_train$realdataresults[[optimal_k_pac_train]][["ordered_data"]]
RNA_seq_cluster_annotation <-
  res_train$realdataresults[[optimal_k_pac_train]][["ordered_annotation"]]

# Joining expression and cluster annotation
RNA_seq_merged <-
  as.data.frame(t(rbind(
    RNA_seq_data, t(RNA_seq_cluster_annotation)
  )))

RNA_seq_merged_allgenes <-
  as.data.frame(merge(t(train_mad), RNA_seq_cluster_annotation, by = "row.names"))
rownames(RNA_seq_merged_allgenes) <-
  RNA_seq_merged_allgenes$Row.names

RNA_seq_merged_allgenes = subset(RNA_seq_merged_allgenes, select = -c(`Row.names`))

# Clinical data
RNA_clin_data <-
  merge(RNA_clin_data, RNA_seq_cluster_annotation, by = "row.names")

rownames(RNA_clin_data) <- RNA_clin_data$Row.names
```

Save the results of the 3 clusters in a set of variables
```{r}
k_clusters_train = 3

data_train <-
  res_train$realdataresults[[k_clusters_train]]$ordered_data
annon_train <-
  res_train$realdataresults[[k_clusters_train]]$ordered_annotation
ccmatrix_train <-
  res_train$realdataresults[[k_clusters_train]]$consensus_matrix
```

Consensus matrix heatmaps from M3C output with ComplexHeatmap.
```{r}
library(ComplexHeatmap)

ccl <- list()
ha_row <- list()
x <- c(
  "skyblue",
  "gold",
  "violet",
  "darkorchid",
  "slateblue",
  "forestgreen",
  "violetred",
  "orange",
  "midnightblue",
  "grey31",
  "black"
)

names(x) <- as.character(seq(1, 11, by = 1))
for (i in seq(2, k_clusters_train)) {
  # get cc matrix and labels
  ccmatrix <- res_train$realdataresults[[i]]$consensus_matrix
  db_source <- as.data.frame(RNA_clin_data[
                c(rownames(res_train$realdataresults[[i]]$ordered_annotation)),
                  "source_db"])
  rownames(db_source) <-
    c(rownames(res_train$realdataresults[[i]]$ordered_annotation))
  colnames(db_source) <- c("db_source")
  annon <- res_train$realdataresults[[i]]$ordered_annotation
  
  # do heatmap
  n <- 10
  seq <- rev(seq(0, 255,
                 by = 255 / (n)))
  palRGB <- cbind(seq,
                  seq, 255)
  mypal <- rgb(palRGB,
               maxColorValue = 255)
  ha = HeatmapAnnotation(
    df = data.frame(Cluster = as.character(annon[, 1])),
    Source = as.character(db_source[, 1]),
    col = list(
      Cluster = x,
      Source = c(
        "TCGA_RNAseq" = "green",
        "Ref2_RNAseq" = "red",
        "RefGSE20271_Array" = "blue",
        "RefGSE575678_Array" = "pink",
        "Ref4_RNAseq" = "yellow"
      )
    )
  )
  ccl[[i]] <- Heatmap(
    ccmatrix,
    name = "Consensus_index",
    top_annotation = ha,
    col = mypal,
    show_row_dend = FALSE,
    show_column_dend = FALSE,
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_column_names = FALSE
  )
}

print(ccl)
```
From looking at the heatmap, we can discard that the clustering was biased by the batch effect of the data sources.

**K-means clustering**
We proceed to apply a K-means clustering procedure on the PCA selected components.
```{r}
k_train <- kmeans(x_train[["x"]][,1:PCs_to_keep],
                  centers = k_clusters_train)
```

We plot the resulting clusters
```{r}
# Add clusters obtained using the K-means algorithm
x_train$cluster <- factor(k_train$cluster)
eigenvalue <- round(get_eigenvalue(x_train), 1)
variance.percent_train <- eigenvalue$variance.percent
```

```{r}
library(ggpubr)
library(dplyr)

temp <- do.call("cbind", list(x_train[["x"]][,1:PCs_to_keep],as.data.frame(x_train$cluster)))

ggscatter(
  temp,
  x = "PC1",
  y = "PC2",
  color = "x_train$cluster",
  palette = "npg",
  ellipse = TRUE,
  ellipse.type = "convex",
  size = 1.5,
  legend = "right",
  ggtheme = theme_bw(),
  xlab = paste0("Dim 1 (", variance.percent_train[1], "% )"),
  ylab = paste0("Dim 2 (", variance.percent_train[2], "% )")
) +
  stat_mean(aes(color = `x_train$cluster`), size = 4)
```

```{r}
# setting the dataframes in a list
list_of_data = list(temp, RNA_clin_data)

# this will get the intersection of the row.names for everything in the list
common_names = Reduce(intersect, lapply(list_of_data, row.names))
common_names
```


```{r}
library(ggrepel)
library(factoextra)
library(ggpubr)

temp <- temp[row.names(temp) %in% common_names,]

source_db <- as.factor(RNA_clin_data$source_db)
temp$source_db <- source_db


ggscatter(
  temp,
  x = "PC1",
  y = "PC2",
  palette = "npg",
  ellipse = TRUE,
  ellipse.type = "convex",
  size = 1.5,
  legend = "right",
  ggtheme = theme_bw(),
  color = "source_db",
  xlab = paste0("Dim 1 (", variance.percent_train[1], "% )"),
  ylab = paste0("Dim 2 (", variance.percent_train[2], "% )")
)
```
By looking at the previous plot, we confirm (once again), that the clustering was not biased due to the difference in data sources and gene expression techniques.

## Consensus Clustering (second method: NMF)
```{r}
options(stringsAsFactors=F)
source("~/TNBC_Research/code/analysis/nmfconsensus.R")

train_mad_combat_nmf <- t(apply(train_mad, 1, scale))
colnames(train_mad_combat_nmf) <- colnames(train_mad)

nmfconsensus(
  input.ds =           "",
  k.init =             2,
  k.final =            5,
  num.clusterings =    100,
  maxniter =           1000,
  error.function =     "euclidean",
  rseed =              1234,
  stopconv =           40,
  stopfreq =           10,
  non.interactive.run = T,
  doc.string =         "neu_nmf",
  data = train_mad_combat_nmf)
```

```{r}
dat.gct <- as.data.frame(read.delim(file="~/TNBC_research/code/csv_and_objects/neu_nmf_results/neu_nmfconsensus.k.2.gct"))
nmf_temp <- as.data.frame(dat.gct[,-1])
colnames(nmf_temp) <- c("nmf_cluster")
rownames(nmf_temp) <- dat.gct[,1]

nmf_temp
```

Let's compare with the consensus clustering results
```{r}
consensus_res <- as.data.frame(ind.coord_train$cluster)
rownames(consensus_res) <- rownames(ind.coord_train)
class(consensus_res$`ind.coord_train$cluster`) <- "Numeric"
consensus_res
```

Find intersections
```{r}
res_df <- merge(nmf_temp, consensus_res, by=0, all=TRUE)
res_df
```

Find the different cluster assignations
```{r}
res_df[which(res_df$nmf_cluster != res_df$`ind.coord_train$cluster`),]
```
In total, there were 42 mismatches of cluster assignations out of 498, (92% clustering similarity between both methods)

## HDBSCAN Clustering

```{r}
# importing the library
library("dbscan")
```

To run the HDBSCAN algorithm, simply pass the dataset and the (single) parameter value ‘minPts’ to the hdbscan function.
```{r}
cl <- hdbscan(x_train[["x"]][,1:PCs_to_keep], minPts = 3)
cl
```

```{r}
plot(x_train[["x"]][,1:3], col=cl$cluster+1, pch=20)
```

```{r}
plot(x_train[["x"]][,1:3], col=cl$cluster+1, pch=21)
colors <- mapply(function(col, i) adjustcolor(col, alpha.f = cl$membership_prob[i]), 
                 palette()[cl$cluster+1], seq_along(cl$cluster))
points(x_train[["x"]][,1:3], col=colors, pch=20)
```

```{r}
plot(cl)
```

```{r}
plot(cl$hc, main="HDBSCAN* Hierarchy", )
```

#### TODO
Let's compare with the consensus clustering results
```{r}
consensus_res <- as.data.frame(ind.coord_train$cluster)
rownames(consensus_res) <- rownames(ind.coord_train)
class(consensus_res$`ind.coord_train$cluster`) <- "Numeric"
consensus_res
```

Find intersections
```{r}
res_df <- merge(nmf_temp, consensus_res, by=0, all=TRUE)
res_df
```

Find the different cluster assignations
```{r}
res_df[which(res_df$nmf_cluster != res_df$`ind.coord_train$cluster`),]
```
In total, there were 42 mismatches of cluster assignations out of 498, (92% clustering similarity between both methods)

## Clinical data visualization per cluster

We split the clinical data in cluster 1, cluster 2 and cluster 3
```{r}
clin_data1 <-
  RNA_clin_data[which(RNA_clin_data["consensuscluster"] == 1),]
clin_data2 <-
  RNA_clin_data[which(RNA_clin_data["consensuscluster"] == 2),]
clin_data3 <-
  RNA_clin_data[which(RNA_clin_data["consensuscluster"] == 3),]
```

**Plotting categorical and numeric variables per cluster**

Counts
```{r}
library(glue)

for (vars in c(
  "age_label",
  "race",
  "histological_grade",
  "histological_type",
  "tumor_size",
  "response_to_treatment",
  "pathological_history",
  "family_pathological_hsitory",
  "age",
  "tumor_size_mm",
  "age_at_menarche",
  "treatment",
  "vital_status",
  "chemotherapy",
  "Surv_event",
  "met_bone",
  "Relapse",
  "Surv_months",
  "methastasis"
)) {
  var1 <- as.data.frame(table(clin_data1[vars]))
  cluster_info <- as.data.frame(rep("1",
                                    nrow(var1)))
  var1 <- cbind(cluster_info,
                var1)
  colnames(var1) <- c("cluster_info",
                      "variable",
                      "count")
  
  
  var2 <- as.data.frame(table(clin_data2[vars]))
  cluster_info <- as.data.frame(rep("2",
                                    nrow(var2)))
  var2 <- cbind(cluster_info, var2)
  colnames(var2) <- c("cluster_info",
                      "variable",
                      "count")
  
  var3 <- as.data.frame(table(clin_data3[vars]))
  cluster_info <- as.data.frame(rep("3",
                                    nrow(var3)))
  var3 <- cbind(cluster_info, var3)
  colnames(var3) <- c("cluster_info",
                      "variable",
                      "count")
  
  
  merged_df <- rbind(var1,
                     var2,
                     var3)
  merged_df
  
  ## PLOTS
  library(ggplot2)
  
  # Grouped barcharts
  plt <- ggplot(merged_df,
                aes(x = cluster_info,
                    y = count,
                    fill = variable)) +
    geom_bar(position = "dodge",
             stat = "identity")+ 
      stat_compare_means()+
      labs(title = as.character(vars))
  
  if (vars %in% c("age",
                  "tumor_size_mm",
                  "age_at_menarche",
                  "Surv_months")) {
    merged_df <- rbind(clin_data1[c("consensuscluster", vars)],
                       clin_data2[c("consensuscluster", vars)],
                       clin_data3[c("consensuscluster", vars)])
    colnames(merged_df) <- c("consensuscluster",
                             "vars")
    
    plt <- ggboxplot(merged_df, 
                  x="consensuscluster",
                  y="vars",
                  color = "consensuscluster",
                  ggtheme = theme_gray(),
                  add='jitter') +
                  stat_compare_means() +
                  labs(title = as.character(vars)) +
                  xlab("Cluster") + ylab(vars)
                  
  }
  
  print(plt)
}

```
Overall, at least visually, the plots seem to have a similar distribution of clinical values. The main highlights so far could be done on the proportions, e.g. 
- The cluster 1 is the only one where methastasis was not present, with cluster 3 being the group with higher proportion of methastasis.
- The cluster 2 presents the lower survival months, meaning that it could represent the group with the lowest survival expectency.
- The cluster 1 participants presented an earlier age at menarche compared to the other clusters.
- The cluster 1 presents slightlier younger individuals than the other two clusters.
- The cluster 3 presented a higher percentage of poor response to treatment, the cluster 2 presented a higher percentage of partial response to treatment, meanwhile the cluster 1 presented equal odds between partial and poor.
- The cluster 1 doesn't present cancer with histological stage = 1.
- The cluster 2 presents the highest percentage of not hispanic or latino samples.
- The cluster 1 is composed of younger individuals than cluster 2 and 3.
   

Percentages
```{r}
library(glue)

for (vars in c(
  "age_label",
  "race",
  "histological_grade",
  "histological_type",
  "tumor_size",
  "response_to_treatment",
  "pathological_history",
  "family_pathological_hsitory",
  "age",
  "tumor_size_mm",
  "age_at_menarche",
  "treatment",
  "vital_status",
  "chemotherapy",
  "Surv_event",
  "met_bone",
  "Relapse",
  "Surv_months",
  "methastasis"
)) {
  var1 <- as.data.frame(table(clin_data1[vars]))
  cluster_info <- as.data.frame(rep("1",
                                    nrow(var1)))
  var1 <- cbind(cluster_info,
                var1)
  
  var1_perc <- var1
  var1_perc$Freq <-  (var1$Freq/sum(var1$Freq))
  
  colnames(var1) <- c("cluster_info",
                      "variable",
                      "count")
  colnames(var1_perc) <- c("cluster_info",
                      "variable",
                      "percentage")
  
  
  var2 <- as.data.frame(table(clin_data2[vars]))
  cluster_info <- as.data.frame(rep("2",
                                    nrow(var2)))
  var2 <- cbind(cluster_info, var2)
  
  var2_perc <- var2
  var2_perc$Freq <-  (var2$Freq/sum(var2$Freq))
  
  colnames(var2) <- c("cluster_info",
                      "variable",
                      "count")
  colnames(var2_perc) <- c("cluster_info",
                      "variable",
                      "percentage")
  
  
  var3 <- as.data.frame(table(clin_data3[vars]))
  cluster_info <- as.data.frame(rep("3",
                                    nrow(var3)))
  var3 <- cbind(cluster_info, var3)
  
  var3_perc <- var3
  var3_perc$Freq <-  (var3$Freq/sum(var3$Freq))
  
  colnames(var3) <- c("cluster_info",
                      "variable",
                      "count")
  colnames(var3_perc) <- c("cluster_info",
                      "variable",
                      "percentage")
  
  
  merged_df <- rbind(var1_perc,
                     var2_perc,
                     var3_perc)
  
  merged_df
  
  ## PLOTS
  library(ggplot2)
  
  # Grouped barcharts
  plt <- ggplot(merged_df,
                aes(x = cluster_info,
                    y = percentage,
                    fill = variable)) +
    geom_bar(position = "dodge",
             stat = "identity")+ 
      stat_compare_means()+
      labs(title = as.character(vars)) + scale_y_continuous(labels = scales::percent)
  
  if (vars %in% c("age",
                  "tumor_size_mm",
                  "age_at_menarche",
                  "Surv_months")) {
    merged_df <- rbind(clin_data1[c("consensuscluster", vars)],
                       clin_data2[c("consensuscluster", vars)],
                       clin_data3[c("consensuscluster", vars)])
    colnames(merged_df) <- c("consensuscluster",
                             "vars")
    
    plt <- ggboxplot(merged_df, 
                  x="consensuscluster",
                  y="vars",
                  color = "consensuscluster",
                  ggtheme = theme_gray(),
                  add='jitter') +
                  stat_compare_means() +
                  labs(title = as.character(vars)) +
                  xlab("Cluster") + ylab(vars)
                  
  }
  
  print(plt)
}

```

## Significance tests on clinical information

Take a look at the clinical data
```{r}
RNA_clin_data[0:10, 0:10] 
```

### SURVIVAL PLOT

The Kaplan–Meier estimator, also known as the product limit estimator, is a non-parametric statistic used to estimate the survival function from lifetime data. In medical research, it is often used to measure the fraction of patients living for a certain amount of time after treatment.
```{r}
library("survminer")
require("survival")

# survival in days
fit_days <- survfit(Surv(Surv_days, Surv_event) ~ consensuscluster, data = RNA_clin_data)
# survival in months
fit_months <- survfit(Surv(Surv_months, Surv_event) ~ consensuscluster, data = RNA_clin_data)
```

Plotting both survival plots
```{r}
ggsurvplot(fit_days, data = RNA_clin_data)
ggsurvplot(fit_months, data = RNA_clin_data)
```

```{r}
ggsurvplot(
  fit_days,
  data = RNA_clin_data,
  size = 1,                 # change line size
  conf.int = TRUE,          # Add confidence interval
  pval = TRUE,              # Add p-value
  risk.table = TRUE,        # Add risk table
  xlab = "Time in days",   # customize X axis label.
  break.time.by = 365,     # break X axis in time intervals by 500.
  risk.table.height = 0.3, # Useful to change when you have multiple groups
  ggtheme = theme_bw(),      # Change ggplot2 theme,
  ncensor.plot = F      # plot the number of censored subjects at time t
)
```

Look at the statistical information of one of the survival plots
```{r}
res.sum <- surv_summary(fit_months)
res.sum
```

Cox Proportional Hazards Model
```{r}
# Fit Cox Model
cox <-
  coxph(Surv(Surv_months, Surv_event) ~ consensuscluster, data = RNA_clin_data)

summary(cox)
```

Plot the Cox analysis

But is there a more systematic way to look at the different covariates? As you might remember from one of the previous passages, Cox proportional hazards models allow you to include covariates. You can build Cox proportional hazards models using the coxph function and visualize them using the ggforest. These type of plot is called a forest plot. It shows so-called hazard ratios (HR) which are derived from the model for all covariates that we included in the formula in coxph. Briefly, an HR > 1 indicates an increased risk of death (according to the definition of h(t)) if a specific condition is met by a patient. An HR < 1, on the other hand, indicates a decreased risk.

```{r}
cox_fit <- survfit(cox)

ggsurvplot(
  cox_fit,
  data = RNA_clin_data,
  size = 1,                 # change line size
  conf.int = TRUE,          # Add confidence interval
  pval = TRUE,              # Add p-value
  risk.table = TRUE,        # Add risk table
  xlab = "Time in days",   # customize X axis label.
  risk.table.height = 0.3, # Useful to change when you have multiple groups
  ggtheme = theme_bw(),      # Change ggplot2 theme,
  ncensor.plot = F      # plot the number of censored subjects at time t
)
```

```{r}
library("ggplot2")
library("survminer")
library("survival")

# Fit a Cox proportional hazards model
fit.coxph <- coxph(Surv(Surv_months, Surv_event) ~ consensuscluster, data = RNA_clin_data)

ggforest(fit.coxph, data = RNA_clin_data)
```

```{r}
summary(fit.coxph)
```



## Statistical tests on clinical data
### Statistical test: histological type

Calculate the count, mean and standard deviation of the 3 groups
```{r}
library(dplyr)

group_by(RNA_clin_data, RNA_clin_data$consensuscluster) %>%
  summarise(
    count = n(),
    mean = mean(histological_type, na.rm = TRUE),
    sd = sd(histological_type, na.rm = TRUE)
  )
```

Calculate the frequencies of each class into each cluster
```{r}
temp_table <- table(RNA_clin_data[c("histological_type", "consensuscluster")])
temp_table
```
Calculate the proportion of the total classes frequencies belonging to each cluster
```{r}
ftable(round(prop.table(temp_table), 3))
```

Bar plot, with each bar representing 100%
```{r}
ggplot(RNA_clin_data, 
       aes(x = consensuscluster, 
           fill = histological_type)) + 
  geom_bar(position = "fill") +
  labs(y = "Proportion")
```

#### Logistic regression on histological type

Cluster 1 vs Cluster 2
```{r}
# Load the package
library(caTools)
library(nnet)

#logistic regression model
model <-
  glm(
    formula = consensuscluster ~ histological_type,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=3,],
    family = binomial
  )
summary(model)
```

Cluster 1 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ histological_type,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=2,],
    family = binomial
  )
summary(model)
```

Cluster 2 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ histological_type,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=1,],
    family = binomial
  )
summary(model)
```

-  Deviance residuals look good, since they are symmetrical and close to 0
-  According to the P-Values and effect size (1.74), the histological_type == Lobular indicates statistical significance.
-  Ductal (the intercept) is also statistically significant, but the effect size is low compared to Lobular.

As the cluster 2 has the majority of Lobular patients, we can infer that cluster 2 has normally a higher number of Lobular BC patients compared to cluster 1. 


#### Chi2 test on histological type
```{r}
## Saving the possible outcomes of the feature
mut_chisq_test_names <- c()
variable_to_check <- "histological_type"
values_to_check <- unique(RNA_clin_data$histological_type)
values_to_check <- values_to_check[is.na(values_to_check) != TRUE]

for (value in c(values_to_check)) {
  cluster1_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  
  cluster1 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  df <- data.frame(cluster1 = c(0, 0), cluster2 = c(0, 0), cluster3 = c(0, 0))
  
  
  df$cluster1 <- c(cluster1_no, cluster1)
  df$cluster2 <- c(cluster2_no, cluster2)
  df$cluster3 <- c(cluster3_no, cluster3)
  
  rownames(df) <- c("0", "1")
  
  chisq_test_var <- chisq.test(df, simulate.p.value = T)
  mut_chisq_test <- c(chisq_test_var$p.value)
  
  ## CALCULATING EFFECT SIZE
  # Custom function
  Cramers_V <- function(chi, n, df_es)
    sqrt((chi) / (n * df_es))
  # Find degrees of freedom - min row or col - 1
  df_es <- min(dim(df)) - 1
  # Calculate
  effect_size <-
    Cramers_V(chi = chisq_test_var$statistic,
              n = sum(df),
              df = df_es)
  
  # we save the P values and FDR of each test
  mut_chisq_test <-
    cbind(mut_chisq_test, p.adjust(mut_chisq_test), effect_size, df_es)
  colnames(mut_chisq_test) <- c("p_value", "fdr", "effect_size", "DOF")
  
  # we order the resulting matrix by P value
  print(value)
  print(mut_chisq_test)
}

```


Doing the chi2 test on the entire variable (not per category only)
```{r}
## Saving the possible outcomes of the feature
mut_chisq_test_names <- c()
variable_to_check <- "histological_type"
values_to_check <- unique(RNA_clin_data$histological_type)
values_to_check <- values_to_check[is.na(values_to_check) != TRUE]

# is the row cluster 1 or cluster 2
cluster1 <-
  table(RNA_clin_data[which(RNA_clin_data[, "consensuscluster"] == 1), ]$histological_type)
cluster2 <-
  table(RNA_clin_data[which(RNA_clin_data[, "consensuscluster"] == 2), ]$histological_type)

clusters_df <-  cbind(cluster1, cluster2)
clusters_df <- as.table(t(clusters_df))
dimnames(clusters_df) <-
  list(cluster = c("1", "2"),
       histological_type = c(colnames(clusters_df)))

chisq_test_var <- chisq.test(clusters_df, simulate.p.value = T)
mut_chisq_test <- c(chisq_test_var$p.value)

## CALCULATING EFFECT SIZE
# Custom function
Cramers_V <- function(chi, n, df)
  sqrt((chi) / (n * df))
# Find degrees of freedom - min row or col - 1
df <- min(dim(clusters_df)) - 1
# Calculate
effect_size <-
  Cramers_V(chi = chisq_test_var$statistic,
            n = sum(clusters_df),
            df = df)

# we save the P values and FDR of each test
mut_chisq_test <-
  cbind(mut_chisq_test, p.adjust(mut_chisq_test), effect_size, df)
colnames(mut_chisq_test) <-
  c("p_value", "fdr", "effect_size", "DOF")

# we order the resulting matrix by P value
print(chisq_test_var)
print(mut_chisq_test)

```


### Statistical test: race

Calculate the count, mean and standard deviation of the 3 groups
```{r}
library(dplyr)

group_by(RNA_clin_data, RNA_clin_data$consensuscluster) %>%
  summarise(
    count = n(),
    mean = mean(race, na.rm = TRUE),
    sd = sd(race, na.rm = TRUE)
  )
```

Calculate the frequencies of each class into each cluster
```{r}
temp_table <- table(RNA_clin_data[c("race", "consensuscluster")])
temp_table
```
Calculate the proportion of the total classes frequencies belonging to each cluster
```{r}
ftable(round(prop.table(temp_table), 3))
```

Bar plot, with each bar representing 100%
```{r}
ggplot(RNA_clin_data, 
       aes(x = consensuscluster, 
           fill = race)) + 
  geom_bar(position = "fill") +
  labs(y = "Proportion")
```

#### Logistic regression on race

Cluster 1 vs Cluster 2
```{r}
# Load the package
library(caTools)
library(nnet)

#logistic regression model
model <-
  glm(
    formula = consensuscluster ~ race,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=3,],
    family = binomial
  )
summary(model)
```

Cluster 1 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ race,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=2,],
    family = binomial
  )
summary(model)
```

Cluster 2 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ race,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=1,],
    family = binomial
  )
summary(model)
```

-  Deviance residuals look good, since they are symmetrical and close to 0
-  According to the P-Values and effect size (1.74), the histological_type == Lobular indicates statistical significance.
-  Ductal (the intercept) is also statistically significant, but the effect size is low compared to Lobular.

As the cluster 2 has the majority of Lobular patients, we can infer that cluster 2 has normally a higher number of Lobular BC patients compared to cluster 1. 


#### Chi2 test on race
```{r}
## Saving the possible outcomes of the feature
mut_chisq_test_names <- c()
variable_to_check <- "race"
values_to_check <- unique(RNA_clin_data$race)
values_to_check <- values_to_check[is.na(values_to_check) != TRUE]

for (value in c(values_to_check)) {
  cluster1_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  
  cluster1 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  df <- data.frame(cluster1 = c(0, 0), cluster2 = c(0, 0), cluster3 = c(0, 0))
  
  
  df$cluster1 <- c(cluster1_no, cluster1)
  df$cluster2 <- c(cluster2_no, cluster2)
  df$cluster3 <- c(cluster3_no, cluster3)
  
  rownames(df) <- c("0", "1")
  
  chisq_test_var <- chisq.test(df, simulate.p.value = T)
  mut_chisq_test <- c(chisq_test_var$p.value)
  
  ## CALCULATING EFFECT SIZE
  # Custom function
  Cramers_V <- function(chi, n, df_es)
    sqrt((chi) / (n * df_es))
  # Find degrees of freedom - min row or col - 1
  df_es <- min(dim(df)) - 1
  # Calculate
  effect_size <-
    Cramers_V(chi = chisq_test_var$statistic,
              n = sum(df),
              df = df_es)
  
  # we save the P values and FDR of each test
  mut_chisq_test <-
    cbind(mut_chisq_test, p.adjust(mut_chisq_test), effect_size, df_es)
  colnames(mut_chisq_test) <- c("p_value", "fdr", "effect_size", "DOF")
  
  # we order the resulting matrix by P value
  print(value)
  print(mut_chisq_test)
}

```

### Statistical test: histological grade

Calculate the count, mean and standard deviation of the 3 groups
```{r}
library(dplyr)

group_by(RNA_clin_data, RNA_clin_data$consensuscluster) %>%
  summarise(
    count = n(),
    mean = mean(histological_grade, na.rm = TRUE),
    sd = sd(histological_grade, na.rm = TRUE)
  )
```

Calculate the frequencies of each class into each cluster
```{r}
temp_table <- table(RNA_clin_data[c("histological_grade", "consensuscluster")])
temp_table
```
Calculate the proportion of the total classes frequencies belonging to each cluster
```{r}
ftable(round(prop.table(temp_table), 3))
```

Bar plot, with each bar representing 100%
```{r}
ggplot(RNA_clin_data, 
       aes(x = consensuscluster, 
           fill = histological_grade)) + 
  geom_bar(position = "fill") +
  labs(y = "Proportion")
```

#### Logistic regression on histological grade

Cluster 1 vs Cluster 2
```{r}
# Load the package
library(caTools)
library(nnet)

#logistic regression model
model <-
  glm(
    formula = consensuscluster ~ histological_grade,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=3,],
    family = binomial
  )
summary(model)
```

Cluster 1 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ histological_grade,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=2,],
    family = binomial
  )
summary(model)
```

Cluster 2 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ histological_grade,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=1,],
    family = binomial
  )
summary(model)
```

-  Deviance residuals look good, since they are symmetrical and close to 0
-  According to the P-Values and effect size (1.74), the histological_type == Lobular indicates statistical significance.
-  Ductal (the intercept) is also statistically significant, but the effect size is low compared to Lobular.

As the cluster 2 has the majority of Lobular patients, we can infer that cluster 2 has normally a higher number of Lobular BC patients compared to cluster 1. 


#### Chi2 test on race
```{r}
## Saving the possible outcomes of the feature
mut_chisq_test_names <- c()
variable_to_check <- "histological_grade"
values_to_check <- unique(RNA_clin_data$histological_grade)
values_to_check <- values_to_check[is.na(values_to_check) != TRUE]

for (value in c(values_to_check)) {
  cluster1_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  
  cluster1 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  df <- data.frame(cluster1 = c(0, 0), cluster2 = c(0, 0), cluster3 = c(0, 0))
  
  
  df$cluster1 <- c(cluster1_no, cluster1)
  df$cluster2 <- c(cluster2_no, cluster2)
  df$cluster3 <- c(cluster3_no, cluster3)
  
  rownames(df) <- c("0", "1")
  
  chisq_test_var <- chisq.test(df, simulate.p.value = T)
  mut_chisq_test <- c(chisq_test_var$p.value)
  
  ## CALCULATING EFFECT SIZE
  # Custom function
  Cramers_V <- function(chi, n, df_es)
    sqrt((chi) / (n * df_es))
  # Find degrees of freedom - min row or col - 1
  df_es <- min(dim(df)) - 1
  # Calculate
  effect_size <-
    Cramers_V(chi = chisq_test_var$statistic,
              n = sum(df),
              df = df_es)
  
  # we save the P values and FDR of each test
  mut_chisq_test <-
    cbind(mut_chisq_test, p.adjust(mut_chisq_test), effect_size, df_es)
  colnames(mut_chisq_test) <- c("p_value", "fdr", "effect_size", "DOF")
  
  # we order the resulting matrix by P value
  print(value)
  print(mut_chisq_test)
}

```



### Statistical test: age

Calculate the count, mean and standard deviation of the 3 groups
```{r}
library(dplyr)

group_by(RNA_clin_data, RNA_clin_data$consensuscluster) %>%
  summarise(
    count = n(),
    mean = mean(age, na.rm = TRUE),
    sd = sd(age, na.rm = TRUE)
  )
```

Boxplot
```{r}
ggplot(RNA_clin_data, 
       aes(x = consensuscluster,
           y = age,
           fill = age)) + 
  geom_jitter(color="black", size=0.5, alpha=0.9) +
  geom_boxplot()
```

#### Logistic regression on age

Cluster 1 vs Cluster 2
```{r}
# Load the package
library(caTools)
library(nnet)

#logistic regression model
model <-
  glm(
    formula = consensuscluster ~ age,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=3,],
    family = binomial
  )
summary(model)
```

Cluster 1 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ age,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=2,],
    family = binomial
  )
summary(model)
```

Cluster 2 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ age,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=1,],
    family = binomial
  )
summary(model)
```

-  Deviance residuals look good, since they are symmetrical and close to 0
-  According to the P-Values and effect size (1.74), the histological_type == Lobular indicates statistical significance.
-  Ductal (the intercept) is also statistically significant, but the effect size is low compared to Lobular.

As the cluster 2 has the majority of Lobular patients, we can infer that cluster 2 has normally a higher number of Lobular BC patients compared to cluster 1. 


#### Chi2 test on age
```{r}
## Saving the possible outcomes of the feature
mut_chisq_test_names <- c()
variable_to_check <- "age"
values_to_check <- unique(RNA_clin_data$age)
values_to_check <- values_to_check[is.na(values_to_check) != TRUE]

for (value in c(values_to_check)) {
  cluster1_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  
  cluster1 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  df <- data.frame(cluster1 = c(0, 0), cluster2 = c(0, 0), cluster3 = c(0, 0))
  
  
  df$cluster1 <- c(cluster1_no, cluster1)
  df$cluster2 <- c(cluster2_no, cluster2)
  df$cluster3 <- c(cluster3_no, cluster3)
  
  rownames(df) <- c("0", "1")
  
  chisq_test_var <- chisq.test(df, simulate.p.value = T)
  mut_chisq_test <- c(chisq_test_var$p.value)
  
  ## CALCULATING EFFECT SIZE
  # Custom function
  Cramers_V <- function(chi, n, df_es)
    sqrt((chi) / (n * df_es))
  # Find degrees of freedom - min row or col - 1
  df_es <- min(dim(df)) - 1
  # Calculate
  effect_size <-
    Cramers_V(chi = chisq_test_var$statistic,
              n = sum(df),
              df = df_es)
  
  # we save the P values and FDR of each test
  mut_chisq_test <-
    cbind(mut_chisq_test, p.adjust(mut_chisq_test), effect_size, df_es)
  colnames(mut_chisq_test) <- c("p_value", "fdr", "effect_size", "DOF")
  
  # we order the resulting matrix by P value
  print(value)
  print(mut_chisq_test)
}

```



### Statistical test: tumor_stage

Calculate the count, mean and standard deviation of the 3 groups
```{r}
library(dplyr)

group_by(RNA_clin_data, RNA_clin_data$consensuscluster) %>%
  summarise(
    count = n(),
    mean = mean(tumor_stage, na.rm = TRUE),
    sd = sd(tumor_stage, na.rm = TRUE)
  )
```

Bar plot, with each bar representing 100%
```{r}
ggplot(RNA_clin_data, 
       aes(x = consensuscluster, 
           fill = tumor_stage)) + 
  geom_bar(position = "fill") +
  labs(y = "Proportion")
```

#### Logistic regression on tumor stage

Cluster 1 vs Cluster 2
```{r}
# Load the package
library(caTools)
library(nnet)

#logistic regression model
model <-
  glm(
    formula = consensuscluster ~ tumor_stage,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=3,],
    family = binomial
  )
summary(model)
```

Cluster 1 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ tumor_stage,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=2,],
    family = binomial
  )
summary(model)
```

Cluster 2 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ tumor_stage,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=1,],
    family = binomial
  )
summary(model)
```

-  Deviance residuals look good, since they are symmetrical and close to 0
-  According to the P-Values and effect size (1.74), the histological_type == Lobular indicates statistical significance.
-  Ductal (the intercept) is also statistically significant, but the effect size is low compared to Lobular.

As the cluster 2 has the majority of Lobular patients, we can infer that cluster 2 has normally a higher number of Lobular BC patients compared to cluster 1. 


#### Chi2 test on tumor_stage
```{r}
## Saving the possible outcomes of the feature
mut_chisq_test_names <- c()
variable_to_check <- "tumor_stage"
values_to_check <- unique(RNA_clin_data$tumor_stage)
values_to_check <- values_to_check[is.na(values_to_check) != TRUE]

for (value in c(values_to_check)) {
  cluster1_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  
  cluster1 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  df <- data.frame(cluster1 = c(0, 0), cluster2 = c(0, 0), cluster3 = c(0, 0))
  
  
  df$cluster1 <- c(cluster1_no, cluster1)
  df$cluster2 <- c(cluster2_no, cluster2)
  df$cluster3 <- c(cluster3_no, cluster3)
  
  rownames(df) <- c("0", "1")
  
  chisq_test_var <- chisq.test(df, simulate.p.value = T)
  mut_chisq_test <- c(chisq_test_var$p.value)
  
  ## CALCULATING EFFECT SIZE
  # Custom function
  Cramers_V <- function(chi, n, df_es)
    sqrt((chi) / (n * df_es))
  # Find degrees of freedom - min row or col - 1
  df_es <- min(dim(df)) - 1
  # Calculate
  effect_size <-
    Cramers_V(chi = chisq_test_var$statistic,
              n = sum(df),
              df = df_es)
  
  # we save the P values and FDR of each test
  mut_chisq_test <-
    cbind(mut_chisq_test, p.adjust(mut_chisq_test), effect_size, df_es)
  colnames(mut_chisq_test) <- c("p_value", "fdr", "effect_size", "DOF")
  
  # we order the resulting matrix by P value
  print(value)
  print(mut_chisq_test)
}

```


### Statistical test: age_at_menarche

Calculate the count, mean and standard deviation of the 3 groups
```{r}
library(dplyr)

group_by(RNA_clin_data, RNA_clin_data$consensuscluster) %>%
  summarise(
    count = n(),
    mean = mean(age_at_menarche, na.rm = TRUE),
    sd = sd(age_at_menarche, na.rm = TRUE)
  )
```

Boxplot
```{r}
ggplot(RNA_clin_data, 
       aes(x = consensuscluster,
           y = age_at_menarche,
           fill = age_at_menarche)) + 
  geom_jitter(color="black", size=0.5, alpha=0.9) +
  geom_boxplot()
```

#### Logistic regression on age at menarche

Cluster 1 vs Cluster 2
```{r}
# Load the package
library(caTools)
library(nnet)

#logistic regression model
model <-
  glm(
    formula = consensuscluster ~ age_at_menarche,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=3,],
    family = binomial
  )
summary(model)
```

Cluster 1 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ age_at_menarche,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=2,],
    family = binomial
  )
summary(model)
```

Cluster 2 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ age_at_menarche,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=1,],
    family = binomial
  )
summary(model)
```

-  Deviance residuals look good, since they are symmetrical and close to 0
-  According to the P-Values and effect size (1.74), the histological_type == Lobular indicates statistical significance.
-  Ductal (the intercept) is also statistically significant, but the effect size is low compared to Lobular.

As the cluster 2 has the majority of Lobular patients, we can infer that cluster 2 has normally a higher number of Lobular BC patients compared to cluster 1. 


#### Chi2 test on age_at_menarche
```{r}
## Saving the possible outcomes of the feature
mut_chisq_test_names <- c()
variable_to_check <- "age_at_menarche"
values_to_check <- unique(RNA_clin_data$age_at_menarche)
values_to_check <- values_to_check[is.na(values_to_check) != TRUE]

for (value in c(values_to_check)) {
  cluster1_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  
  cluster1 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  df <- data.frame(cluster1 = c(0, 0), cluster2 = c(0, 0), cluster3 = c(0, 0))
  
  
  df$cluster1 <- c(cluster1_no, cluster1)
  df$cluster2 <- c(cluster2_no, cluster2)
  df$cluster3 <- c(cluster3_no, cluster3)
  
  rownames(df) <- c("0", "1")
  
  chisq_test_var <- chisq.test(df, simulate.p.value = T)
  mut_chisq_test <- c(chisq_test_var$p.value)
  
  ## CALCULATING EFFECT SIZE
  # Custom function
  Cramers_V <- function(chi, n, df_es)
    sqrt((chi) / (n * df_es))
  # Find degrees of freedom - min row or col - 1
  df_es <- min(dim(df)) - 1
  # Calculate
  effect_size <-
    Cramers_V(chi = chisq_test_var$statistic,
              n = sum(df),
              df = df_es)
  
  # we save the P values and FDR of each test
  mut_chisq_test <-
    cbind(mut_chisq_test, p.adjust(mut_chisq_test), effect_size, df_es)
  colnames(mut_chisq_test) <- c("p_value", "fdr", "effect_size", "DOF")
  
  # we order the resulting matrix by P value
  print(value)
  print(mut_chisq_test)
}

```



### Statistical test: tumor_size

Calculate the count, mean and standard deviation of the 3 groups
```{r}
library(dplyr)

group_by(RNA_clin_data, RNA_clin_data$consensuscluster) %>%
  summarise(
    count = n(),
    mean = mean(tumor_size_mm, na.rm = TRUE),
    sd = sd(tumor_size_mm, na.rm = TRUE)
  )
```

Boxplot
```{r}
ggplot(RNA_clin_data, 
       aes(x = consensuscluster,
           y = tumor_size_mm,
           fill = tumor_size_mm)) + 
  geom_jitter(color="black", size=0.5, alpha=0.9) +
  geom_boxplot()
```

#### Logistic regression on age at menarche

Cluster 1 vs Cluster 2
```{r}
# Load the package
library(caTools)
library(nnet)

#logistic regression model
model <-
  glm(
    formula = consensuscluster ~ tumor_size_mm,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=3,],
    family = binomial
  )
summary(model)
```

Cluster 1 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ tumor_size_mm,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=2,],
    family = binomial
  )
summary(model)
```

Cluster 2 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ tumor_size_mm,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=1,],
    family = binomial
  )
summary(model)
```

-  Deviance residuals look good, since they are symmetrical and close to 0
-  According to the P-Values and effect size (1.74), the histological_type == Lobular indicates statistical significance.
-  Ductal (the intercept) is also statistically significant, but the effect size is low compared to Lobular.

As the cluster 2 has the majority of Lobular patients, we can infer that cluster 2 has normally a higher number of Lobular BC patients compared to cluster 1. 


#### Chi2 test on tumor_size_mm
```{r}
## Saving the possible outcomes of the feature
mut_chisq_test_names <- c()
variable_to_check <- "tumor_size_mm"
values_to_check <- unique(RNA_clin_data$tumor_size_mm)
values_to_check <- values_to_check[is.na(values_to_check) != TRUE]

for (value in c(values_to_check)) {
  cluster1_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  
  cluster1 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  df <- data.frame(cluster1 = c(0, 0), cluster2 = c(0, 0), cluster3 = c(0, 0))
  
  
  df$cluster1 <- c(cluster1_no, cluster1)
  df$cluster2 <- c(cluster2_no, cluster2)
  df$cluster3 <- c(cluster3_no, cluster3)
  
  rownames(df) <- c("0", "1")
  
  chisq_test_var <- chisq.test(df, simulate.p.value = T)
  mut_chisq_test <- c(chisq_test_var$p.value)
  
  ## CALCULATING EFFECT SIZE
  # Custom function
  Cramers_V <- function(chi, n, df_es)
    sqrt((chi) / (n * df_es))
  # Find degrees of freedom - min row or col - 1
  df_es <- min(dim(df)) - 1
  # Calculate
  effect_size <-
    Cramers_V(chi = chisq_test_var$statistic,
              n = sum(df),
              df = df_es)
  
  # we save the P values and FDR of each test
  mut_chisq_test <-
    cbind(mut_chisq_test, p.adjust(mut_chisq_test), effect_size, df_es)
  colnames(mut_chisq_test) <- c("p_value", "fdr", "effect_size", "DOF")
  
  # we order the resulting matrix by P value
  print(value)
  print(mut_chisq_test)
}

```





### Statistical test: Survival months and events

Calculate the count, mean and standard deviation of the 3 groups
```{r}
library(dplyr)

group_by(RNA_clin_data, RNA_clin_data$consensuscluster) %>%
  summarise(
    count = n(),
    mean = mean(Surv_months, na.rm = TRUE),
    sd = sd(Surv_months, na.rm = TRUE)
  )
```

Boxplot
```{r}
ggplot(RNA_clin_data, 
       aes(x = consensuscluster,
           y = Surv_months,
           fill = Surv_months)) + 
  geom_jitter(color="black", size=0.5, alpha=0.9) +
  geom_boxplot()
```

#### Logistic regression on age at menarche

Cluster 1 vs Cluster 2
```{r}
# Load the package
library(caTools)
library(nnet)

#logistic regression model
model <-
  glm(
    formula = consensuscluster ~ Surv_months + Surv_event,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=3,],
    family = binomial
  )
summary(model)
```

Cluster 1 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ Surv_months + Surv_event,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=2,],
    family = binomial
  )
summary(model)
```

Cluster 2 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ Surv_months + Surv_event,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=1,],
    family = binomial
  )
summary(model)
```

-  Deviance residuals look good, since they are symmetrical and close to 0
-  According to the P-Values and effect size (1.74), the histological_type == Lobular indicates statistical significance.
-  Ductal (the intercept) is also statistically significant, but the effect size is low compared to Lobular.

As the cluster 2 has the majority of Lobular patients, we can infer that cluster 2 has normally a higher number of Lobular BC patients compared to cluster 1. 


#### Chi2 test on Surv_months
```{r}
## Saving the possible outcomes of the feature
mut_chisq_test_names <- c()
variable_to_check <- "Surv_months"
values_to_check <- unique(RNA_clin_data$Surv_months)
values_to_check <- values_to_check[is.na(values_to_check) != TRUE]

for (value in c(values_to_check)) {
  cluster1_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  
  cluster1 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  df <- data.frame(cluster1 = c(0, 0), cluster2 = c(0, 0), cluster3 = c(0, 0))
  
  
  df$cluster1 <- c(cluster1_no, cluster1)
  df$cluster2 <- c(cluster2_no, cluster2)
  df$cluster3 <- c(cluster3_no, cluster3)
  
  rownames(df) <- c("0", "1")
  
  chisq_test_var <- chisq.test(df, simulate.p.value = T)
  mut_chisq_test <- c(chisq_test_var$p.value)
  
  ## CALCULATING EFFECT SIZE
  # Custom function
  Cramers_V <- function(chi, n, df_es)
    sqrt((chi) / (n * df_es))
  # Find degrees of freedom - min row or col - 1
  df_es <- min(dim(df)) - 1
  # Calculate
  effect_size <-
    Cramers_V(chi = chisq_test_var$statistic,
              n = sum(df),
              df = df_es)
  
  # we save the P values and FDR of each test
  mut_chisq_test <-
    cbind(mut_chisq_test, p.adjust(mut_chisq_test), effect_size, df_es)
  colnames(mut_chisq_test) <- c("p_value", "fdr", "effect_size", "DOF")
  
  # we order the resulting matrix by P value
  print(value)
  print(mut_chisq_test)
}

```


### Statistical test: Relapse

Calculate the count, mean and standard deviation of the 3 groups
```{r}
library(dplyr)

group_by(RNA_clin_data, RNA_clin_data$consensuscluster) %>%
  summarise(
    count = n(),
    mean = mean(Relapse, na.rm = TRUE),
    sd = sd(Relapse, na.rm = TRUE)
  )
```

Calculate the frequencies of each class into each cluster
```{r}
temp_table <- table(RNA_clin_data[c("Relapse", "consensuscluster")])
temp_table
```
Calculate the proportion of the total classes frequencies belonging to each cluster
```{r}
ftable(round(prop.table(temp_table), 3))
```

Bar plot, with each bar representing 100%
```{r}
ggplot(RNA_clin_data, 
       aes(x = consensuscluster, 
           fill = Relapse)) + 
  geom_bar(position = "fill") +
  labs(y = "Proportion")
```

#### Logistic regression on histological grade

Cluster 1 vs Cluster 2
```{r}
# Load the package
library(caTools)
library(nnet)

#logistic regression model
model <-
  glm(
    formula = consensuscluster ~ Relapse,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=3,],
    family = binomial
  )
summary(model)
```

Cluster 1 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ Relapse,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=2,],
    family = binomial
  )
summary(model)
```

Cluster 2 vs Cluster 3
```{r}
model <-
  glm(
    formula = consensuscluster ~ Relapse,
    data = RNA_clin_data[RNA_clin_data$consensuscluster!=1,],
    family = binomial
  )
summary(model)
```

-  Deviance residuals look good, since they are symmetrical and close to 0
-  According to the P-Values and effect size (1.74), the histological_type == Lobular indicates statistical significance.
-  Ductal (the intercept) is also statistically significant, but the effect size is low compared to Lobular.

As the cluster 2 has the majority of Lobular patients, we can infer that cluster 2 has normally a higher number of Lobular BC patients compared to cluster 1. 


#### Chi2 test on Relapse
```{r}
## Saving the possible outcomes of the feature
mut_chisq_test_names <- c()
variable_to_check <- "Relapse"
values_to_check <- unique(RNA_clin_data$Relapse)
values_to_check <- values_to_check[is.na(values_to_check) != TRUE]

for (value in c(values_to_check)) {
  cluster1_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3_no <-
    length(which(
      RNA_clin_data[, variable_to_check] == value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  
  cluster1 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 1 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster2 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 2 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  cluster3 <-
    length(which(
      RNA_clin_data[, variable_to_check] != value &
        RNA_clin_data[, "consensuscluster"] == 3 &
        is.na(RNA_clin_data[, variable_to_check]) != TRUE
    ))
  
  df <- data.frame(cluster1 = c(0, 0), cluster2 = c(0, 0), cluster3 = c(0, 0))
  
  
  df$cluster1 <- c(cluster1_no, cluster1)
  df$cluster2 <- c(cluster2_no, cluster2)
  df$cluster3 <- c(cluster3_no, cluster3)
  
  rownames(df) <- c("0", "1")
  
  chisq_test_var <- chisq.test(df, simulate.p.value = T)
  mut_chisq_test <- c(chisq_test_var$p.value)
  
  ## CALCULATING EFFECT SIZE
  # Custom function
  Cramers_V <- function(chi, n, df_es)
    sqrt((chi) / (n * df_es))
  # Find degrees of freedom - min row or col - 1
  df_es <- min(dim(df)) - 1
  # Calculate
  effect_size <-
    Cramers_V(chi = chisq_test_var$statistic,
              n = sum(df),
              df = df_es)
  
  # we save the P values and FDR of each test
  mut_chisq_test <-
    cbind(mut_chisq_test, p.adjust(mut_chisq_test), effect_size, df_es)
  colnames(mut_chisq_test) <- c("p_value", "fdr", "effect_size", "DOF")
  
  # we order the resulting matrix by P value
  print(value)
  print(mut_chisq_test)
}

```


## Mutations Analysis
We download the mutations from the available sources 

Ref 2 mutations
```{r}
mut_Ref2 <-
  read.delim(
    file = "C:\\Users\\victo\\OneDrive\\Documentos\\TNBC_research\\Database exploring\\DB compressed files\\Ref 2\\Ref2_untar\\brca_metabric\\data_mutations.txt",
    sep = "\t",
    header = T,
    stringsAsFactors = F,
    skip = 1
  )

mut_Ref2[0:10, 0:10]
```

Ref 4 mutations
```{r}
mut_Ref4 <-
  read.delim(
    file = "C:\\Users\\victo\\OneDrive\\Documentos\\TNBC_research\\Database exploring\\DB compressed files\\Ref 4\\Ref4_untar\\brca_mbcproject_wagle_2017\\data_mutations.txt",
    sep = "\t",
    header = T,
    stringsAsFactors = F,
    skip = 0
  )

mut_Ref4[0:10, 0:10]
```

TCGA mutations
```{r}
mut_TCGA <-
  read.delim(
    file = "C:/Users/victo/OneDrive/Documentos/R/TNBC research/TNBC_research/BRCA-TP.final_analysis_set.maf",
    sep = "\t",
    header = T,
    stringsAsFactors = F
  )

mut_TCGA[0:10, 0:10]
```

Merging the mutation datasets
```{r}
# Columns in common with all the mutation datasets
merged_mut_cols <- intersect(colnames(mut_Ref2), colnames(mut_Ref4))
merged_mut_cols <- intersect(merged_mut_cols, colnames(mut_TCGA))

# Merged mutation datasets
merged_mut <-
  rbind(mut_Ref2[merged_mut_cols], mut_Ref4[merged_mut_cols])
merged_mut <- rbind(merged_mut, mut_TCGA[merged_mut_cols])

merged_mut[0:10, 0:10]
```

We check the data frame dimensions
```{r}
dim(merged_mut)
```

We drop mutations related to: UTR, introns, RNA and silent.
```{r}
mut_filters <-
  c("3'UTR",
    "5'Flank",
    "3'Flank",
    "5'UTR",
    "IGR",
    "Intron",
    "Silent",
    "RNA")
mut_filter_index <-
  which(merged_mut$Variant_Classification %in% mut_filters)
merged_mut <- merged_mut[-mut_filter_index, ]

dim(merged_mut)
```

We can observe the type of mutation in the column "Variant_Classification"
```{r}
table(merged_mut$Variant_Classification)[0:10]
```
We obtain the different samples and genes to make an array where it will store 0 and 1 depending on whether
mutation is present.
```{r}
u_samples <- sort(unique(merged_mut$Tumor_Sample_Barcode))
u_genes <- sort(unique(merged_mut$Hugo_Symbol))
mut_matrix <-
  matrix(
    0,
    nrow = length(u_genes),
    ncol = length(u_samples),
    
    dimnames = list(u_genes, u_samples)
  )

mut_matrix[1:5, 1:5]

mut_matrix <- mut_matrix[, -1]

mut_matrix[1:5, 1:5]
```

We fill the array by doing one loop per sample
```{r}
for(i in colnames(mut_matrix)) {
  aux_genes <-
    merged_mut$Hugo_Symbol[which(merged_mut$Tumor_Sample_Barcode == i)]
  mut_matrix[aux_genes, i] <- 1
}
```


Defining the cluster groups with the patient IDs
```{r}
library(dplyr)
k_clusters = 2
cluster = list()

for (i in seq(1, k_clusters)) {
  cluster[[i]] <- filter(annon, annon$consensuscluster == i)
}
```

We observe the difference in the naming convention of mutations and rna-seq data, as well as the difference in dimensions. We can compare the first 16 characters.
```{r}
raw_brca_rnaseq <- RNA_seq_merged

mut_rnaseq_match <- match(gsub(
  pattern = "-",
  replacement = "\\.",
  x = substr(colnames(mut_matrix), 1, 16)
),
substr(rownames(raw_brca_rnaseq), 1, 16))

mut_rnaseq_match[0:10]
```

Clean the mutation matrix and expression matrix from NA values
```{r}
raw_brca_rnaseq <- t(RNA_seq_merged)

# to store the non NA values postitions
mut_rnaseq_match_nonNA <- which(!is.na(mut_rnaseq_match))

# to remove the NA values from mut_matrix_rna and mut_rnaseq_match
mut_matrix_rna <- mut_matrix[, mut_rnaseq_match_nonNA]
mut_rnaseq_match <- mut_rnaseq_match[mut_rnaseq_match_nonNA]

rna_mut <- raw_brca_rnaseq[, mut_rnaseq_match]

cbind(colnames(mut_matrix_rna)[c(1, 20, 50, 54)], 
      colnames(rna_mut)[c(1, 20, 50, 54)])
```

We filter the genes in RNA-seq that show no variation and we keep the most frequent mutations only.
```{r}
# We convert all the dataframe as numeric
rna_mut <-
  mutate_all(data.frame(rna_mut), function(x)
    as.numeric(as.character(x)))

# We apply the mad function
rna_mut_mad <- apply(rna_mut, 1, mad)
mad_zero <- which(rna_mut_mad == 0)
rna_mut <- rna_mut[-mad_zero, ]
table(apply(mut_matrix_rna, 1, sum))
```

We count the times each mutation appears in the matrix and store the ones with an appearance of >9 times
```{r}
# We count the times each mutation appears in the matrix
mut_matrix_rna_count <- apply(mut_matrix_rna, 1, sum)

# if the mutation count is greater than 9, we add it to the mut_matrix_rna
mut_matrix_rna <- mut_matrix_rna[which(mut_matrix_rna_count > 9), ]

mut_matrix_rna[0:10, 0:10]
```

### T-test mutations merged

We run a t-test to know which genes change according to the mutations
```{r}
mut_rna_test <- c()
mut_rna_test_names <- c()
for (i in 1:nrow(mut_matrix_rna)) {
  # we apply the function "function(x)" to each of the row values of rna_mut where each row value is x
  aux_mut_test <- t(sapply(1:nrow(rna_mut), function(x) {
    # mutation: the mutation row (presence or absence of mutation per gene sequence)
    # exp: the gene row of the rna_mut matrix
    aux_test <-
      t.test(
        formula = exp ~ mut,
        data = data.frame(mut = mut_matrix_rna[i, ],
                          exp = as.matrix(rna_mut)[x, ])
      )
    
    
    aux_test$p.value
  }))
  
  # appending each test into a vector
  mut_rna_test <- c(mut_rna_test, aux_mut_test)
  # appending each name into a vector
  mut_rna_test_names <-
    c(mut_rna_test_names, paste(rownames(mut_matrix_rna)[i], rownames(rna_mut), 
                                sep = "_"))
  
}

# we save the P values and FDR of each test
mut_rna_test <- cbind(mut_rna_test, p.adjust(mut_rna_test))
colnames(mut_rna_test) <- c("p_value", "fdr")
rownames(mut_rna_test) <- mut_rna_test_names

# we order the resulting matrix by P value
mut_rna_test <- mut_rna_test[order(mut_rna_test[, "p_value"]), ]
mut_rna_test[1:5, ]

```

Export the data frame with the p-values to a csv file
```{r}
mut_rna_test <- as.data.frame(mut_rna_test)
mut_rna_test$row_names <- rownames(mut_rna_test)

write.csv(
  as.data.frame(mut_rna_test),
  "C:\\Users\\victo\\OneDrive\\Documentos\\TNBC_research\\Clustering\\Mutations_merged_T_test.csv",
  row.names = FALSE
)
```

### Mtations per cluster
```{r}
mut_matrix_rna <- as.data.frame(mut_matrix_rna)
mut_matrix_rna[0:10,0:10]
```

```{r}
rna_mut[0:10,0:10]
```

```{r}
RNA_seq_merged <- as.data.frame(t(RNA_seq_merged))
RNA_seq_merged[0:10,0:10]
```

```{r}
colnames(RNA_seq_merged[,which(RNA_seq_merged["consensuscluster",] == 2)])[0:10]
```

```{r}
colnames(RNA_seq_merged[,which(RNA_seq_merged["consensuscluster",] == 1)])[0:10]
```

```{r}
mut_rnaseq_match_cluster1 <-
  match(gsub(
    pattern = "-",
    replacement = "\\.",
    x = substr(colnames(rna_mut), 1, 16)
  ),
  substr(colnames(
    RNA_seq_merged[, which(RNA_seq_merged["consensuscluster", ] == 1)]), 1, 16))

# to store the NA values postitions
NA_cluster1 <- which(is.na(mut_rnaseq_match_cluster1))

# to remove the NA values from mut_matrix_rna and mut_rnaseq_match
mut_matrix_rna_cluster1 <- mut_matrix_rna[, -NA_cluster1]
mut_rnaseq_match_cluster1 <- mut_rnaseq_match_cluster1[-NA_cluster1]
rna_mut_cluster1 <- rna_mut[-NA_cluster1]

print(dim(rna_mut_cluster1))
print(dim(mut_matrix_rna_cluster1))
```
```{r}
mut_rnaseq_match_cluster2 <-
  match(gsub(
    pattern = "-",
    replacement = "\\.",
    x = substr(colnames(rna_mut), 1, 16)
  ),
  substr(colnames(
    RNA_seq_merged[, which(RNA_seq_merged["consensuscluster", ] == 2)]), 1, 16))

# to store the NA values postitions
NA_cluster2 <- which(is.na(mut_rnaseq_match_cluster2))

# to remove the NA values from mut_matrix_rna and mut_rnaseq_match
mut_matrix_rna_cluster2 <- mut_matrix_rna[, -NA_cluster2]
mut_rnaseq_match_cluster2 <- mut_rnaseq_match_cluster2[-NA_cluster2]
rna_mut_cluster2 <- rna_mut[-NA_cluster2]

print(dim(rna_mut_cluster2))
print(dim(mut_matrix_rna_cluster2))
```

### Chi2 mutations merged

We run a chi2 to know which genes change according to the mutations
```{r}
mut_rna_test <- c()
mut_rna_test_names <- c()
for (i in 1:nrow(mut_matrix_rna)) {
  # mutation: the mutation row (presence or absence of mutation per gene sequence)
  # exp: the gene row of the rna_mut matrix
  ones1 <- sum(mut_matrix_rna_cluster1[i, ])
  zeros1 <- length(mut_matrix_rna_cluster1[i, ]) - ones1
  
  ones2 <- sum(mut_matrix_rna_cluster2[i, ])
  zeros2 <- length(mut_matrix_rna_cluster2[i, ]) - ones2
  
  mut_clust <- as.table(rbind(c(zeros1, zeros2), c(ones1, ones2)))
  dimnames(mut_clust) <- list(status = c("No mutation", "Mutation"),
                              cluster = c("1", "2"))
  
  aux_mut_test <- chisq.test(mut_clust, simulate.p.value = T)$p.value
  
  # appending each test into a vector
  mut_rna_test <- c(mut_rna_test, aux_mut_test)
  # appending each name into a vector
  mut_rna_test_names <-
    c(mut_rna_test_names, paste(rownames(mut_matrix_rna)[i]))
}

# we save the P values and FDR of each test
mut_rna_test <- cbind(mut_rna_test, p.adjust(mut_rna_test))
colnames(mut_rna_test) <- c("p_value", "fdr")
rownames(mut_rna_test) <- mut_rna_test_names

# we order the resulting matrix by P value
mut_rna_test <- mut_rna_test[order(mut_rna_test[, "p_value"]), ]
mut_rna_test[1:15, ]
```

Export the data frame with the p-values to a csv file
```{r}
mut_rna_test <- as.data.frame(mut_rna_test)
mut_rna_test$row_names <- rownames(mut_rna_test)

write.csv(
  as.data.frame(mut_rna_test),
  "C:\\Users\\victo\\OneDrive\\Documentos\\TNBC_research\\Clustering\\Mutations_clusters_Chi2_test.csv",
  row.names = FALSE
)

mut_rna_test$
```

Comparing the differentially expressed genes between both clusters
```{r}
significant_mutations <- filter(mut_rna_test, p_value < 0.05)$row_names

cc1 <- colMeans(t(mut_matrix_rna_cluster1))
cc2 <- colMeans(t(mut_matrix_rna_cluster2))

temp <- cbind(cc1[significant_mutations], cc2[significant_mutations])

rownames(temp) <- significant_mutations
colnames(temp) <- c("cluster1", "cluster2")

temp
```

## DEGs (Differentially expressed genes among clusters)
## CIBERSORT*
- Infiltración de células inmunes
- Biopsia > Perfil transcriptómico > Proporcion de celulas T en esa biopsia de cancer de mama

 
 Calcular xCel > Matriz (fila subtipo celular y col muestra) > relacionar cada una de esas proporciones con el PC1 
  (TBD)
## 1. COX (Survival) (DONE)
Load the libraries
```{r}
library(survival)
library(ranger)
library(ggplot2)
library(dplyr)
library(ggfortify)
```



## 2. PATHWAYS

First we get the genes set corresponding to the "homo sapiens" specie (human). 
```{r}
human_gene_sets = msigdbr(species = "Homo sapiens", category = "H")
head(human_gene_sets)
```

Save the list of all the available gene symbols for the homo sapiens gene set
```{r}
m_list = human_gene_sets %>% split(x = .$gene_symbol, f = .$gs_name)
m_list
```

Take a look at the first rows of the normalized genes used for the clustering analysis.
```{r}
head(train_mad)
```

Save the gene symbols of the most significantly expressed genes per cluster to explore their pathways.
```{r}
# Take the previously created matrix and transform to dataframe
temp_significant_genes <- as.data.frame(temp)

# Filter the genes for cluster 1 
sign_genes_cluster1 <- row.names(temp_significant_genes)[which(is.na(temp_significant_genes$cluster1))]

# Filter the genes for cluster 2 
sign_genes_cluster2 <- row.names(temp_significant_genes)[which(is.na(temp_significant_genes$cluster2))]

# Filter the genes for cluster 3
sign_genes_cluster3 <- row.names(temp_significant_genes)[which(is.na(temp_significant_genes$cluster3))]
```

Filter the main genes dataframe to include only the genes mainly represented in each cluster.
```{r}
# Transform the m_list into a vector to perform the intersections
m_list_vector <-  unlist(m_list)

# Cluster 1 gene intersection and filtering
intersecting_genes_cluster1 <-
  intersect(m_list_vector, sign_genes_cluster1)
genes_df_cluster1 <-
  train_mad[row.names(train_mad) %in% intersecting_genes_cluster1, ]

# Cluster 2 gene intersection and filtering
intersecting_genes_cluster2 <-
  intersect(m_list_vector, sign_genes_cluster2)
genes_df_cluster2 <-
  train_mad[row.names(train_mad) %in% intersecting_genes_cluster2, ]

# Cluster 3 gene intersection and filtering
intersecting_genes_cluster3 <-
  intersect(m_list_vector, sign_genes_cluster3)
genes_df_cluster3 <-
  train_mad[row.names(train_mad) %in% intersecting_genes_cluster3, ]

# All clusters intersection and filtering
intersecting_genes_all_clusters <-
  intersect(m_list_vector, c(sign_genes_cluster1, sign_genes_cluster2, sign_genes_cluster3))
genes_df_all_clusters <-
  train_mad[row.names(train_mad) %in% intersecting_genes_all_clusters, ]
```

```{r}
# Transform the m_list into a vector to perform the intersections
m_list_vector <-  unlist(m_list)

# Cluster 1 gene intersection and filtering
samples_cluster1 <- row.names(RNA_clin_data[RNA_clin_data$consensuscluster == 1,])
intersecting_genes_cluster1 <-
  intersect(m_list_vector, sign_genes_cluster1)
genes_df_cluster1 <-
  train_mad[row.names(train_mad) %in% intersecting_genes_cluster1, samples_cluster1]

# Cluster 2 gene intersection and filtering
samples_cluster2 <- row.names(RNA_clin_data[RNA_clin_data$consensuscluster == 2,])
intersecting_genes_cluster2 <-
  intersect(m_list_vector, sign_genes_cluster2)
genes_df_cluster2 <-
  train_mad[row.names(train_mad) %in% intersecting_genes_cluster2, samples_cluster2]

# Cluster 3 gene intersection and filtering
samples_cluster3 <- row.names(RNA_clin_data[RNA_clin_data$consensuscluster == 3,])
intersecting_genes_cluster3 <-
  intersect(m_list_vector, sign_genes_cluster3)
genes_df_cluster3 <-
  train_mad[row.names(train_mad) %in% intersecting_genes_cluster3, samples_cluster3]

# All clusters intersection and filtering
intersecting_genes_all_clusters <-
  intersect(m_list_vector, c(sign_genes_cluster1, sign_genes_cluster2, sign_genes_cluster3))
genes_df_all_clusters <-
  train_mad[row.names(train_mad) %in% intersecting_genes_all_clusters, ]
```


Now, lets explore the pathways for each cluster
```{r}
library(msigdbr)

# cluster 1
hallmarks_ssgsea_cluster1 <- GSVA::gsva(as.matrix(genes_df_cluster1), 
                               gset.idx.list = m_list, 
                               method= "ssgsea",
                               verbose= FALSE)
# cluster 2
hallmarks_ssgsea_cluster2 <- GSVA::gsva(as.matrix(genes_df_cluster2), 
                               gset.idx.list = m_list, 
                               method= "ssgsea",
                               verbose= FALSE)
# cluster 3
hallmarks_ssgsea_cluster3 <- GSVA::gsva(as.matrix(genes_df_cluster3), 
                               gset.idx.list = m_list, 
                               method= "ssgsea",
                               verbose= FALSE)

# all clusters
hallmarks_ssgsea_all_clusters <- GSVA::gsva(as.matrix(genes_df_all_clusters), 
                               gset.idx.list = m_list, 
                               method= "ssgsea",
                               verbose= FALSE)

```

## 3. xCELL 
- xCell is a webtool that performs cell type enrichment analysis from gene expression data for 64 immune and stroma cell types.
- xCell is a gene signatures-based method learned from thousands of pure cell types from various sources.
- calcula un score llamado single sample GSEA, genes marcadores de subtipos marcadores o pathways.
    - single sample GSEA > GS
    - Pathways > Hallmark 
    
## Next steps
- Buscar datos de single cell si COX resulta positivo


