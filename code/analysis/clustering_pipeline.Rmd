---
title: "TNBC Clustering (Gene expression, mutations, clinical data)"
author: "Victoria Rios"
date: "30/08/2022"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Data Analysis of TNBC gene expression information and mutations

***

## Import Data

Avoid strings being recognized as factors and import libraries used in the next chunks of code.
```{r}
options(stringsAsFactors = F)

library(factoextra)
library(M3C)
library(plyr)
```

### Expression data

Import resulting data frames containing gene expression data (previously normalized with log2 and batch effect assessed by ComBat), where each column is a sample and each row a gene.

characteristic      | train | train_mad 
----------------------------------------
rows (genes)        | 10856 | 2648   
columns (samples)   | 509   | 509

```{r}
# Read the csv files containing the dataframes
train <-
  read.csv("~/TNBC_Research/code/csv_and_objects/ComBat/ComBat.csv",
           row.names = "row.names")
train_mad <-
  read.csv("~/TNBC_Research/code/csv_and_objects/ComBat/ComBat_mad.csv",
           row.names = "row.names")
```

Observe the first records of the gene expression data frame
```{r}
head(train_mad)
```


### Clinical data

Import the clinical information data frame that matches with the samples found in the genetic information data frame imported in the previous chunks of code (specifically "train_mad").
```{r}
# Read the csv file with the clinical information
RNA_clin_data <-
  read.csv(
    "~/TNBC_Research/code/csv_and_objects/ComBat/clinical_data_combat_mad.csv",
    row.names = "row.names"
  )

# Set ID as a new column (this will be used in the Consensus Clustering section of the analysis)
RNA_clin_data$ID <- row.names(RNA_clin_data)
```

Observe the first records of the clinical information data frame
```{r}
head(RNA_clin_data)
```

Verify the shapes of the imported data frames.
```{r}
library(glue)

glue("Train -> rows(genes): {nrow(train)}, columns(samples): {ncol(train)}")
glue("Train_mad -> rows(genes): {nrow(train_mad)}, columns(samples): {ncol(train_mad)}")
glue("RNA_clin_data -> rows(samples): {nrow(RNA_clin_data)}, columns(clinical variables): {ncol(RNA_clin_data)}")
```

***

## Data Engineering

### Clean Data

Once we have the data, we need to ensure that it is in a format that we can use to create a model or perform statistical tests.

```{r}
# Format for the expression data
str(train_mad[,1:5])

# Format for the clinical data
str(RNA_clin_data)
```
The expression data is numeric, which is the desired format for the analysis. For the clinical data, there are a couple modifications that are required for the correct performance of the analysis:
- age -> int
- methastasis -> boolean
- histological_grade -> int
- tumor_stage -> int
- chemotherapy -> boolean
- radiotherapy -> boolean
- hormone_therapy -> boolean
- relapse_free_status -> int
- hispanic -> boolean
- met_* -> boolean
- response_to_treatment -> int (mapping)
- tabaquism -> boolean
- pathological_history -> boolean
- family_pathological_hsitory -> boolean
- relapse -> boolean
- TNBC_status -> boolean


It is needed to perform feature engineering, specially on the categorical clinical features, since some of the classes are correlated or even duplicated among the set of unique labels per feature. A manual renaming of the classes is performed to account for this issue.
```{r}
# Define a vector with the names of the features to engineer
features_to_engineer <- c("histological_type",
                          "histological_grade",
                          "race",
                          "age",
                          "age_at_menarche",
                          "tumor_size_mm",
                          "days_to_last_followup",
                          "chemotherapy",
                          "radiotherapy",
                          "hormone_therapy",
                          "relapse_free_status",
                          "tumor_stage",
                          "methastasis",
                          "response_to_treatment",
                          "tabaquism",
                          "hispanic",
                          "pathological_history",
                          "family_pathological_hsitory",
                          "Relapse",
                          "TNBC_status",
                          "relapse_free_status"
                          )

# Define a loop to go over each feature and make the classes compliant
for (feature in features_to_engineer) {
  
  # Display the unique values of the raw features
  print(unique(RNA_clin_data[feature]))
  
  if (feature == "histological_type") {
    RNA_clin_data$histological_type <-
      mapvalues(RNA_clin_data$histological_type,
                c("Mixed (not specified)", "Not specified"),
                c("Mixed", NA))
  } else if (feature == "histological_grade") {
    RNA_clin_data$histological_grade <-
      mapvalues(
        RNA_clin_data$histological_grade,
        c(
          "UNKNOWN",
          "N/A",
          "Unknown",
          "II-III",
          "I LOW GRADE (WELL DIFFERENTIATED)",
          "3",
          "2",
          "1"
        ),
        c(NA, NA, NA, 2, 1, 3, 2, 1)
      )
    
    # Change to factor
    RNA_clin_data$histological_grade <- as.factor(RNA_clin_data$histological_grade)
    
  } else if (feature == "chemotherapy") {
    RNA_clin_data$chemotherapy <-
      mapvalues(
        RNA_clin_data$chemotherapy,
        c(
          "Doxorubicin",
          "Paclitaxel",
          "Adriamicin",
          "N/A",
          "Epirubicin",
          "NO",
          "YES"
        ),
        c(1, 1, 1, NA, 1, 0, 1)
      )
    
    # Change to factor
    RNA_clin_data$chemotherapy <- as.factor(RNA_clin_data$chemotherapy)
    
  } else if (feature == "histological_grade") {
    RNA_clin_data$histological_grade <-
      mapvalues(
        RNA_clin_data$histological_grade,
        c(
          "1",
          "2",
          "3"
        ),
        c(1, 2, 3)
      )
    
    # Change to factor
    RNA_clin_data$histological_grade <- as.factor(RNA_clin_data$histological_grade)
    
  } else if (feature == "tabaquism") {
    RNA_clin_data$tabaquism <-
      mapvalues(
        RNA_clin_data$tabaquism,
        c(
          "Neg",
          "Pos"
        ),
        c(0, 1)
      )
    
    # Change to factor
    RNA_clin_data$tabaquism <- as.factor(RNA_clin_data$tabaquism)
    
  } else if (feature == "hispanic") {
    RNA_clin_data$hispanic <-
      mapvalues(
        RNA_clin_data$hispanic,
        c(
          "NO",
          "YES"
        ),
        c(0, 1)
      )
    
    # Change to factor
    RNA_clin_data$hispanic <- as.factor(RNA_clin_data$hispanic)
    
  } else if (feature == "Relapse") {
    RNA_clin_data$Relapse <-
      mapvalues(
        RNA_clin_data$Relapse,
        c(
          "TRUE",
          "FALSE"
        ),
        c(1, 0)
      )
    
    # Change to factor
    RNA_clin_data$Relapse <- as.factor(RNA_clin_data$Relapse)
    
  } else if (feature == "TNBC_status") {
    RNA_clin_data$TNBC_status <-
      mapvalues(
        RNA_clin_data$TNBC_status,
        c(
          TRUE,
          FALSE
        ),
        c(1, 0)
      )
    
    # Change to factor
    RNA_clin_data$TNBC_status <- as.factor(RNA_clin_data$TNBC_status)
    
  } else if (feature == "pathological_history") {
    RNA_clin_data$pathological_history <-
      mapvalues(
        RNA_clin_data$pathological_history,
        c(
          "Neg",
          "Hypothyroidism",
          "Diabetes",
          "Ocular Surgery",
          "3 C sections",
          "Hysterechtomy",
          "Hypertension and Diabetes"
        ),
        c(0, 1, 1, 1, 1, 1, 1)
      )
    
    # Change to factor
    RNA_clin_data$pathological_history <- as.factor(RNA_clin_data$pathological_history)
    
  } else if (feature == "family_pathological_hsitory") {
    RNA_clin_data$family_pathological_hsitory <-
      mapvalues(
        RNA_clin_data$family_pathological_hsitory,
        c(
          "Neg",
          "Maternal Aunt Breast Cancer",                                                                           
          "Diabetes",                                                                                              
          "Liver Cancer",                                                                                          
          "Father Pancreas Cancer. Maternal Aunt Breast Cancer. Father Aunts Ovarian Cancer. Cousin Breast Cancer",
          "Father Laringeal Cancer",                                                                               
          "Fater Liver Cancer",                                                                                    
          "Mother and Sister Ovarian Cancer"   
        ),
        c(0, 1, 1, 1, 1, 1, 1, 1)
      )
    
    # Change to factor
    RNA_clin_data$family_pathological_hsitory <- as.factor(RNA_clin_data$family_pathological_hsitory)
    
  } else if (feature == "radiotherapy") {
    RNA_clin_data$radiotherapy <-
      mapvalues(
        RNA_clin_data$radiotherapy,
        c(
          "Yes",
          "No",
          "N/A",
          "NO",
          "YES"
        ),
        c(1, 0, NA, 0, 1)
      )
    # Change to factor
    RNA_clin_data$radiotherapy <- as.factor(RNA_clin_data$radiotherapy)
    
  } else if (feature == "hormone_therapy") {
    RNA_clin_data$hormone_therapy <-
      mapvalues(
        RNA_clin_data$hormone_therapy,
        c(
          "NO",
          "YES"
        ),
        c(0, 1)
      )
    # Change to factor
    RNA_clin_data$hormone_therapy <- as.factor(RNA_clin_data$hormone_therapy)
    
  } else if (feature == "methastasis") {
    RNA_clin_data$methastasis <-
      mapvalues(
        RNA_clin_data$methastasis,
        c(
          "no",
          "yes",
          "0",
          "1"
        ),
        c(0, 1, 0, 1)
      )
    # Change to factor
    RNA_clin_data$methastasis <- as.factor(RNA_clin_data$methastasis)
    
  } else if (feature == "relapse_free_status") {
    RNA_clin_data$relapse_free_status <-
      mapvalues(
        RNA_clin_data$relapse_free_status,
        c(
          "0:Not Recurred",
          "1:Recurred"
        ),
        c(0, 1)
      )
    # Change to numeric
    RNA_clin_data$relapse_free_status <- as.numeric(RNA_clin_data$relapse_free_status)
  
  } else if (feature == "tumor_stage") {
    RNA_clin_data$tumor_stage <-
      mapvalues(
        RNA_clin_data$tumor_stage,
        c(
          "N/A",
          "UNKNOWN",
          "3B",
          "2B",
          "1",
          "2",
          "3",
          "4"
        ),
        c(NA, NA, 3, 2, 1, 2, 3, 4)
      )
    # Change to factor
    RNA_clin_data$tumor_stage <- as.factor(RNA_clin_data$tumor_stage)
    
  } else if (feature == "race") {
    RNA_clin_data$race <-
      mapvalues(
        RNA_clin_data$race,
        c(
          "W",
          "B",
          "H",
          "UNKNOWN",
          "WHITE",
          "BLACK OR AFRICAN AMERICAN",
          "OTHER"
        ),
        c(
          "white",
          "african american",
          "hispanic or latino",
          NA,
          "white",
          "african american",
          NA
        )
      )
  } else if (feature == "age") {
    
    # Change age to numeric
    RNA_clin_data$age <- as.numeric(RNA_clin_data$age)
    
    # Add a new variant of the age as ranges
    RNA_clin_data$age_label <- RNA_clin_data$age
    
    for (age_row in 1:nrow(RNA_clin_data)) {
      if (is.na(RNA_clin_data[age_row, "age"]) == FALSE) {
        if (RNA_clin_data[age_row, "age"] < 40) {
          RNA_clin_data[age_row, "age_label"] <- "30s"
        }
        if (RNA_clin_data[age_row, "age"] >= 40 &
            RNA_clin_data[age_row, "age"] < 50) {
          RNA_clin_data[age_row, "age_label"] <- "40s"
        }
        if (RNA_clin_data[age_row, "age"] >= 50 &
            RNA_clin_data[age_row, "age"] < 60) {
          RNA_clin_data[age_row, "age_label"] <- "50s"
        }
        if (RNA_clin_data[age_row, "age"] >= 60 &
            RNA_clin_data[age_row, "age"] < 70) {
          RNA_clin_data[age_row, "age_label"] <- "60s"
        }
        if (RNA_clin_data[age_row, "age"] >= 70 &
            RNA_clin_data[age_row, "age"] < 80) {
          RNA_clin_data[age_row, "age_label"] <- "70s"
        }
        if (RNA_clin_data[age_row, "age"] >= 80 &
            RNA_clin_data[age_row, "age"] < 90) {
          RNA_clin_data[age_row, "age_label"] <- "80s"
        }
        if (RNA_clin_data[age_row, "age"] >= 90) {
          RNA_clin_data[age_row, "age_label"] <- "90s"
        }
      }
    }
  } else if (feature == "tumor_size_mm") {
    
    # Change tumor size to numeric
    RNA_clin_data$tumor_size_mm <- as.numeric(RNA_clin_data$tumor_size_mm)
    # Add a new variant of the tumor size as ranges
    RNA_clin_data$tumor_size <- RNA_clin_data$tumor_size_mm
    
    for (age_row in 1:nrow(RNA_clin_data)) {
      if (is.na(RNA_clin_data[age_row, "tumor_size_mm"]) == FALSE) {
        if (RNA_clin_data[age_row, "tumor_size_mm"] < 10) {
          RNA_clin_data[age_row, "tumor_size"] <- "Below 10 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 10 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 20) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 10 and 19 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 20 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 30) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 20 and 29 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 30 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 40) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 30 and 39 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 40 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 50) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 40 and 49 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 50 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 60) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 50 and 59 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 60 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 70) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 60 and 69 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 70 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 80) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 70 and 79 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 80 &
            RNA_clin_data[age_row, "tumor_size_mm"] < 90) {
          RNA_clin_data[age_row, "tumor_size"] <- "Between 80 and 89 mm"
        }
        if (RNA_clin_data[age_row, "tumor_size_mm"] >= 90) {
          RNA_clin_data[age_row, "tumor_size"] <- "Greater than 89 mm"
        }
      }
    }
    
  } else if (feature == "days_to_last_followup") {
    RNA_clin_data$Surv_event <- NA
    RNA_clin_data$Surv_months <- NA
    RNA_clin_data$Surv_days <- NA
    
    for (i in 1:nrow(RNA_clin_data)) {
      if (is.na(RNA_clin_data$days_to_last_followup[i]) != T) {
        RNA_clin_data$Surv_months[i] <-
          RNA_clin_data$days_to_last_followup[i] / 30
        RNA_clin_data$Surv_days[i] <-
          RNA_clin_data$days_to_last_followup[i]
      }
      if (is.na(RNA_clin_data$survival_months[i]) != T) {
        RNA_clin_data$Surv_months[i] <- RNA_clin_data$survival_months[i]
        RNA_clin_data$Surv_days[i] <-
          RNA_clin_data$survival_months[i] * 30
      }
      if (isTRUE(is.na(RNA_clin_data$vital_status[i]) != T) &
          RNA_clin_data$vital_status[i] %in% c("alive", "Living")) {
        RNA_clin_data$Surv_event[i] <- 0
      }
      if (isTRUE(is.na(RNA_clin_data$vital_status[i]) != T) &
          RNA_clin_data$vital_status[i] %in% c("dead", "Died of Disease") == T) {
        RNA_clin_data$Surv_event[i] <- 1
      }
    }
  }
  
  # Display the unique values of the engineered features
  print(unique(RNA_clin_data[feature]))
}

RNA_clin_data <- RNA_clin_data[,!(names(RNA_clin_data) %in% c("last_known_alive"))]

RNA_clin_data$relapse_free_status <- as.factor(RNA_clin_data$relapse_free_status)

```
```{r}
head(RNA_clin_data)
```


### Data profiling report of the clinical data

Before running the data profiling report, let's verify the columns that could be dropped based on missing values > 60%.
```{r}
# Load the library
library(mde)

# Get a report of the missing variables per column
missing_summary <- na_summary(RNA_clin_data, sort_by = "percent_missing")
missing_summary
```
```{r}
# Saving the names of the variables with missing values above 60
vars_missing_above60 <- as.vector(missing_summary[missing_summary$percent_missing>=60,]$variable)
vars_missing_above60
```

Drop the variables with above 60% missing data
```{r}
RNA_clin_data <- RNA_clin_data[,!(names(RNA_clin_data) %in% vars_missing_above60)]
```

Generate Data profiling report
```{r}
library(DataExplorer)
create_report(RNA_clin_data)
```


### Handling missing values

Print the dimensions of the clinical data set to verify if the plot will correctly fit the screen or if it needs to be split.
```{r}
dim(RNA_clin_data)
```

List the missing values per column
```{r}
# Load the library
library(mde)

# Get a report of the missing variables per column
na_summary(RNA_clin_data, sort_by = "percent_missing")

```
The clinical variables that present <60% of missing values, we specially focus on these clinical variables for the statistical tests and correlation with the clusters resulting from the analysis.

Taking that into account, there is a total of 20 clinical variables to plot for a better understanding of the distribution of the missing values in the clinical data.

```{r}
# Load the library for visualization
library(naniar)

# Plot the first half of the data
vis_miss(RNA_clin_data, sort_miss = T)
```
Most of the missing values seem to be aligned to similar samples, giving an indicator of being tied to the data source, which is acceptable as long as the resulting clusters are not influenced by the data source.

Verify the classes of the variables of interest.
```{r}
sapply(RNA_clin_data, class)
```

Separate numeric from categorical variables
```{r}
clinical_vars_names <- colnames(RNA_clin_data)

cat_vars_clin <- clinical_vars_names[-c(1,6,14,15,19,21,22)]
num_vars_clin <- clinical_vars_names[c(1,6,14,15,19,21,22)]
```

### Feature Scaling

As seen in the data profiling report, most of the data is skewed or non-normally distributed. Feature scaling is necessary to more accurate statistical results.
```{r}
library(caret)

skewed_vars <-
  c(
    "age",
    "relapse_free_months",
    "Surv_days",
    "Surv_months",
    "survival_months",
    "tumor_size_mm"
  )

for (variable in skewed_vars) {
  print(RNA_clin_data[1:5, variable])
  
  RNA_clin_data[, variable] <- sqrt( RNA_clin_data[, variable])
  
  hist(RNA_clin_data[,variable])
  
  print(RNA_clin_data[1:5, variable])
}
```



Let's run the profiling report once again to verify the skewness of the data is gone.
```{r}
create_report(RNA_clin_data)
```
Our variables are more normally distributed.


***

## Dimensionality reduction

There is a great need to develop analytical methodology to analyze and to exploit the information contained in gene expression data. Because of the large number of genes and the complexity of biological networks, clustering is a useful exploratory technique for analysis of gene expression data. Prior starting the clustering process, principal component analysis (PCA) is needed to reduce the dimensionality of our large and complex data set and allow us to explain the data in a matrix of fewer dimensions (more manageable and memory efficient).

### Principal components analysis (PCA)
To compute a PCA in R we use the prcomp() function. This function takes a matrix of data, where the columns are the variables that we want to use to transform our samples, which should be the rows of the matrix.

In this case, we look for similarities across our patients (samples = rows) based on gene expression (variables = columns). For that reason, we provide a transposed version of our table to the prcomp() function as shown in the cell below:
```{r}
t(train_mad)[1:10,1:10]
```

Pass the transposed expression dataframe to the prcomp() function, so each row represents a sample and each column a gene.
```{r}
# Principal components analysis
x_train <- prcomp(t(train_mad), scale = T)
```

Visualize eigenvalues (scree plot) to show the percentage of data variance explained by each principal component. We target to keep ~75-85% of the variance from the original dataset.
```{r}
scree_plot <- fviz_eig(x_train, addlabels=TRUE)
scree_plot
```
As seen in the plot, we are not able to get the desired variance percentage even after adding up the first 2 Principal Components (PCs), therefore, more than 2 PCs are used for model training. On the other side, only two PCs are used to visualize the data points in a reader-friendly manner (Note: It is also possible to visualize the data in 3 dimensions if required to add an additional level of explainability to the graph).


### Graph of individuals
Plot the first two PCs to visualize the results of the dimensionality reduction technique on the gene expression data.
```{r}
# Plot the PCA
fviz_pca_ind(
  x_train,
  col.ind = "cos2",
  # Color by the quality of representation
  gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
  repel = T,
  # Avoid text overlapping,
  max.overlaps = Inf
)
```

Visual verification of the differences across different pairs of components.
This helps identifying differential descriptive Principal Components across different variables, if there is no clear difference, only the first 2 PCs are kept to continue the global analysis.
```{r}
vals_to_check <- as.factor(RNA_clin_data$tumor_stage)

# PC1 vs PC2
plot(
  x_train$rotation[, 1],
  x_train$rotation[, 2],
  xlab = "PCA component 1",
  ylab = "PCA component 2",
  col = vals_to_check
)

# PC1 vs PC3
plot(
  x_train$rotation[, 1],
  x_train$rotation[, 3],
  xlab = "PCA component 1",
  ylab = "PCA component 3",
  col = vals_to_check
)

# PC2 vs PC3
plot(
  x_train$rotation[, 2],
  x_train$rotation[, 3],
  xlab = "PCA component 2",
  ylab = "PCA component 3",
  col = vals_to_check
)
```
There isn't an apparent difference in the data explained by the first 6 components with the highest explained variance, so, we proceed with the analysis with a visualization focused on the first two PCs.

***

## Consensus Clustering

**Extract taken from the M3C package documentation (https://rdrr.io/bioc/M3C/f/vignettes/M3Cvignette.Rmd)**

Genome-wide expression data is used to stratify patients into classes using clustering algorithms for precision medicine. The Monti consensus clustering algorithm (Monti et al., 2003) is a widely applied method to identify the number of clusters (K) through the principle of stability selection. This algorithm works by resampling and clustering the data for each K and a NXN consensus matrix is calculated, where each element represents the fraction of times two samples clustered together. A perfectly stable matrix would consist entirely of 0s and 1s, representing all sample pairs always clustering together or not together over resampling iterations. 

The next step is to compare the stability of these consensus matrices to decide K. The Proportion of Ambiguous Clustering (PAC) score (Senbabaoglu et al., 2014) has been proposed to assess consensus matrix stability for each K, however, it has bias towards greater values of K. This is due to a general problem with this type of consensus clustering algorithm that occurs because as K increases the consensus matrix converges towards a matrix of perfect stability simply by chance. The alternative well used delta K metric to find K is subjective as it relies on finding an elbow point and has been demonstrated to be inferior to the PAC score. 

Monte Carlo reference-based consensus clustering (M3C) (John et al., 2018) was made to solve these problems by comparing the real stability scores with those expected under a random model. M3C uses a Monte Carlo simulation to generate null distributions of stability scores along the range of K which, by comparing with the real stability scores, are used to decide the optimal K and reject the null hypothesis K=1.

Choose the number of components that will represent ~85% of the variance of the data
```{r}
# Define a variable with the PCs to keep
PCs_to_keep = 285

# Print the cumulative explained variance of a range of PCs
summary(x_train)$importance[3, 1:PCs_to_keep][PCs_to_keep]

```

### Consensus Clustering with PAC score as objective function

Define the annotation data frame with the clinical variables to test
```{r}
# Annotation dataframe
anno_df_m3c <- RNA_clin_data[,clinical_vars_names]

# Change gene expression data type to numeric
x_train[["x"]] <-
  mutate_all(as.data.frame(x_train[["x"]]), function(x)
    as.numeric(as.character(x)))
```

Perform consensus clustering on the normalized data
```{r}
library(dplyr)

# Pass the gene expression data frame to perform consensus clustering
# Where each row is a PC and each column is a sample.
res_train <- M3C(
  data.frame(t(x_train[["x"]][,1:PCs_to_keep])),
  des = anno_df_m3c,
  seed = 123,
  removeplots = TRUE,
  iters = 50,
  fsize = 8,
  lthick = 1,
  dotsize = 1.25
)

# Save the optimal K
optimal_k_train = max(res_train[["assignments"]])

```

Also important is the relationship between the clinical variables and the discovered clusters. In this data we
want to compare with a categorical variable so perform a chi-squared test. We are reassured to see below
K=3 is highly significant.
```{r}

for (variable in cat_vars_clin[2:10]) {
  temp_var <- c()
  for (k in seq(2, 5)) {
    myresults <- res_train$realdataresults[[k]]$ordered_annotation
    chifit <-
      suppressWarnings(chisq.test(table(myresults[c('consensuscluster', variable)])))
    temp_var <- c(temp_var, round(chifit$p.value, 4))
  }
  print(variable)
  print(temp_var)
}
```

The results of the chi-squared test for the categorical variables of interest indicate that for K=3, the following categorical variables are significant:
- histological_type
- vital_status
- histological_grade
- hormone therapy
- menopausal_state

(Optional) Save the result of consensus clustering for later
```{r}
## Uncomment to save the result object to a local file
#saveRDS(res_train,
#        file = "~/TNBC_Research/code/csv_and_objects/clustering/consensus_clustering_M3C_170922.rds")
# Restore the object
res_train <- readRDS(file = "~/TNBC_Research/code/csv_and_objects/clustering/consensus_clustering_M3C_170922.rds")
```

### Display the consensus clustering scores for the selected K

The scores and p values for the PAC score objective function are contained within the res$scores object. We can see below the RCSI reaches a maxima at K = 3, the p_score supports this optimal K decision. This means the null hypothesis that K = 1 can be rejected for this data set because we have achieved significance (alpha=0.05) versus a data set with no clusters.
```{r}
# Consensus clustering scores
res_train$scores
```

The stability index (RCSI) is the highest for K=3, as well as it being associated with the lowest P scores, which confirms the consensus clustering selection. 

### Visualize the consensus clustering plots

**1. CDF Plot**

In the CDF and following PAC plot we can see the inherent bias of consensus clustering where as K increases so does the apparent stability of the results (or CDF plot flatness), this we correct for by using a reference. This makes the method more sensitive to detection of the underlying structure in noisy data.

```{r}
res_train$plots[[1]]
```
The line starts flattening or stabilizing at K=3. Showing the performance of an optimal K.


**2. PAC Score**

This figure below shows the PAC score, we can see an elbow at K = 3 which is suggestive this is the best K. However, the bias of consensus clustering can be seen here as the PAC score naturally tends towards lower values as K increases (see above plot), making selecting K without taking this into account subject to bias. Selecting the minimal PAC score will only work when the clusters are very well separated.

```{r}
res_train$plots[[2]]
```

**3. Relative Cluster Stability Index (RCSI)**

The Relative Cluster Stability Index (RCSI) was derived and associated 95% confidence intervals which take into account the reference PAC scores using the reference mean. This metric is better than the PAC score for deciding class number, where the maximum value corresponds to the optimal K. In this example the RCSI has an optima at K=3. Either the *RCSI* or *P scores* can be used to select K. 

```{r}
res_train$plots[[3]]
```

**4. P score**

Calculate the P score from the distribution, here we display the P scores from the beta distribution. If none of the P scores reach significance over a reasonable range of K (e.g. 10), then we accept the null hypothesis. In this dataset, we can see K = 3 reaches signficance with an alpha of 0.05, therefore we can reject the null hypothesis K=1.
```{r}
res_train$plots[[3]]
```

After the analysis, we can be convinced that there are 3 clusters within this data set which are not likely to have
occurred by chance alone.


### Understanding M3C Outputs

The cell below extracts the ordered expression data and the ordered annotation data from the results object after running M3C for a 3 cluster solution. We then take a look at the annotation object M3C outputs, a consensus cluster column has been added by M3C.

Gather the RNA-seq data and clinical data from the clustering results as different variables.
```{r}
# RNA-seq data and cluster annotation
RNA_seq_data <-
  res_train$realdataresults[[optimal_k_train]][["ordered_data"]]
RNA_seq_cluster_annotation <-
  res_train$realdataresults[[optimal_k_train]][["ordered_annotation"]]

# Joining expression and cluster annotation
RNA_seq_merged <-
  as.data.frame(t(rbind(
    RNA_seq_data, t(RNA_seq_cluster_annotation)
  )))

RNA_seq_merged_allgenes <-
  as.data.frame(merge(t(train_mad), RNA_seq_cluster_annotation, by = "row.names"))
rownames(RNA_seq_merged_allgenes) <-
  RNA_seq_merged_allgenes$Row.names

RNA_seq_merged_allgenes = subset(RNA_seq_merged_allgenes, select = -c(`Row.names`))

# Clinical data
RNA_clin_data <-
  merge(RNA_clin_data, RNA_seq_cluster_annotation, by = "row.names")

rownames(RNA_clin_data) <- RNA_clin_data$Row.names
```

Remove any possible duplicate column
```{r}
library(stringr)

RNA_clin_data <- RNA_clin_data %>% 
  rename_at(
    vars(ends_with(".x")),
    ~str_replace(., "\\..$","")
  ) %>% 
  select_at(
    vars(-ends_with(".y"))
  )
```


Save the results of the 3 clusters in a set of variables
```{r}
k_clusters_train = 3

data_train <-
  res_train$realdataresults[[k_clusters_train]]$ordered_data
annon_train <-
  res_train$realdataresults[[k_clusters_train]]$ordered_annotation
ccmatrix_train <-
  res_train$realdataresults[[k_clusters_train]]$consensus_matrix
```

Consensus matrix heatmaps from M3C output with ComplexHeatmap.
```{r}
library(ComplexHeatmap)

ccl <- list()
ha_row <- list()
x <- c(
  "skyblue",
  "gold",
  "violet",
  "darkorchid",
  "slateblue",
  "forestgreen",
  "violetred",
  "orange",
  "midnightblue",
  "grey31",
  "black"
)

names(x) <- as.character(seq(1, 11, by = 1))
for (i in seq(2, k_clusters_train)) {
  # get cc matrix and labels
  ccmatrix <- res_train$realdataresults[[i]]$consensus_matrix
  db_source <- as.data.frame(RNA_clin_data[
                c(rownames(res_train$realdataresults[[i]]$ordered_annotation)),
                  "source_db"])
  rownames(db_source) <-
    c(rownames(res_train$realdataresults[[i]]$ordered_annotation))
  colnames(db_source) <- c("db_source")
  annon <- res_train$realdataresults[[i]]$ordered_annotation
  
  # do heatmap
  n <- 10
  seq <- rev(seq(0, 255,
                 by = 255 / (n)))
  palRGB <- cbind(seq,
                  seq, 255)
  mypal <- rgb(palRGB,
               maxColorValue = 255)
  ha = HeatmapAnnotation(
    df = data.frame(Cluster = as.character(annon[, 1])),
    Source = as.character(db_source[, 1]),
    col = list(
      Cluster = x,
      Source = c(
        "TCGA_RNAseq" = "green",
        "Ref2_RNAseq" = "red",
        "RefGSE20271_Array" = "blue",
        "RefGSE575678_Array" = "pink",
        "Ref4_RNAseq" = "yellow"
      )
    )
  )
  ccl[[i]] <- Heatmap(
    ccmatrix,
    name = "Consensus_index",
    top_annotation = ha,
    col = mypal,
    show_row_dend = FALSE,
    show_column_dend = FALSE,
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_column_names = FALSE
  )
}

print(ccl)
```
From looking at the heatmap, we can discard that the clustering was biased by the batch effect of the data sources.

**K-means clustering**
We proceed to apply a K-means clustering procedure on the PCA selected components.
```{r}
set.seed(100)
k_train <- kmeans(x_train[["x"]][,1:PCs_to_keep],
                  centers = k_clusters_train
                  )
```

We plot the resulting clusters
```{r}
# Add clusters obtained using the K-means algorithm
x_train$cluster <- factor(k_train$cluster)
eigenvalue <- round(get_eigenvalue(x_train), 1)
variance.percent_train <- eigenvalue$variance.percent
```

```{r}
library(ggpubr)
library(dplyr)

temp <- do.call("cbind", list(x_train[["x"]][,1:PCs_to_keep],as.data.frame(x_train$cluster)))

ggscatter(
  temp,
  x = "PC1",
  y = "PC2",
  color = "x_train$cluster",
  palette = "npg",
  ellipse = TRUE,
  ellipse.type = "convex",
  size = 1.5,
  legend = "right",
  ggtheme = theme_bw(),
  xlab = paste0("Dim 1 (", variance.percent_train[1], "% )"),
  ylab = paste0("Dim 2 (", variance.percent_train[2], "% )")
) +
  stat_mean(aes(color = `x_train$cluster`), size = 4)
```

```{r}
# setting the data frames in a list
list_of_data = list(temp, RNA_clin_data)

# this will get the intersection of the row.names for everything in the list
common_names = Reduce(intersect, lapply(list_of_data, row.names))
common_names
```

By looking at the previous plot, we confirm (once again), that the clustering was not biased due to the difference in data sources and gene expression techniques.

## Clinical data visualization per cluster

We split the clinical data in cluster 1, cluster 2 and cluster 3
```{r}
clin_data1 <-
  RNA_clin_data[which(RNA_clin_data["consensuscluster"] == 1),]
clin_data2 <-
  RNA_clin_data[which(RNA_clin_data["consensuscluster"] == 2),]
clin_data3 <-
  RNA_clin_data[which(RNA_clin_data["consensuscluster"] == 3),]
```

### Plotting categorical and numeric variables per cluster

Counts
```{r}
library(glue)

for (vars in clinical_vars_names) {
  var1 <- as.data.frame(table(clin_data1[vars]))
  cluster_info <- as.data.frame(rep("1",
                                    nrow(var1)))
  var1 <- cbind(cluster_info,
                var1)
  colnames(var1) <- c("cluster_info",
                      "variable",
                      "count")
  
  
  var2 <- as.data.frame(table(clin_data2[vars]))
  cluster_info <- as.data.frame(rep("2",
                                    nrow(var2)))
  var2 <- cbind(cluster_info, var2)
  colnames(var2) <- c("cluster_info",
                      "variable",
                      "count")
  
  var3 <- as.data.frame(table(clin_data3[vars]))
  cluster_info <- as.data.frame(rep("3",
                                    nrow(var3)))
  var3 <- cbind(cluster_info, var3)
  colnames(var3) <- c("cluster_info",
                      "variable",
                      "count")
  
  
  merged_df <- rbind(var1,
                     var2,
                     var3)
  merged_df
  
  ## PLOTS
  library(ggplot2)
  
  # Grouped barcharts
  plt <- ggplot(merged_df,
                aes(x = cluster_info,
                    y = count,
                    fill = variable)) +
    geom_bar(position = "dodge",
             stat = "identity")+ 
      stat_compare_means()+
      labs(title = as.character(vars))
  
  if (vars %in% c("age",
                  "tumor_size_mm",
                  "age_at_menarche",
                  "Surv_months")) {
    merged_df <- rbind(clin_data1[c("consensuscluster", vars)],
                       clin_data2[c("consensuscluster", vars)],
                       clin_data3[c("consensuscluster", vars)])
    colnames(merged_df) <- c("consensuscluster",
                             "vars")
    
    plt <- ggboxplot(merged_df, 
                  x="consensuscluster",
                  y="vars",
                  color = "consensuscluster",
                  ggtheme = theme_gray(),
                  add='jitter') +
                  stat_compare_means() +
                  labs(title = as.character(vars)) +
                  xlab("Cluster") + ylab(vars)
                  
  }
  
  print(plt)
}

```

Percentages
```{r}
library(glue)

for (vars in clinical_vars_names) {
  var1 <- as.data.frame(table(clin_data1[vars]))
  cluster_info <- as.data.frame(rep("1",
                                    nrow(var1)))
  var1 <- cbind(cluster_info,
                var1)
  
  var1_perc <- var1
  var1_perc$Freq <-  (var1$Freq/sum(var1$Freq))
  
  colnames(var1) <- c("cluster_info",
                      "variable",
                      "count")
  colnames(var1_perc) <- c("cluster_info",
                      "variable",
                      "percentage")
  
  
  var2 <- as.data.frame(table(clin_data2[vars]))
  cluster_info <- as.data.frame(rep("2",
                                    nrow(var2)))
  var2 <- cbind(cluster_info, var2)
  
  var2_perc <- var2
  var2_perc$Freq <-  (var2$Freq/sum(var2$Freq))
  
  colnames(var2) <- c("cluster_info",
                      "variable",
                      "count")
  colnames(var2_perc) <- c("cluster_info",
                      "variable",
                      "percentage")
  
  
  var3 <- as.data.frame(table(clin_data3[vars]))
  cluster_info <- as.data.frame(rep("3",
                                    nrow(var3)))
  var3 <- cbind(cluster_info, var3)
  
  var3_perc <- var3
  var3_perc$Freq <-  (var3$Freq/sum(var3$Freq))
  
  colnames(var3) <- c("cluster_info",
                      "variable",
                      "count")
  colnames(var3_perc) <- c("cluster_info",
                      "variable",
                      "percentage")
  
  
  merged_df <- rbind(var1_perc,
                     var2_perc,
                     var3_perc)
  
  merged_df
  
  ## PLOTS
  library(ggplot2)
  
  # Grouped barcharts
  plt <- ggplot(merged_df,
                aes(x = cluster_info,
                    y = percentage,
                    fill = variable)) +
    geom_bar(position = "dodge",
             stat = "identity")+ 
      stat_compare_means()+
      labs(title = as.character(vars)) + scale_y_continuous(labels = scales::percent)
  
  if (vars %in% c("age",
                  "tumor_size_mm",
                  "age_at_menarche",
                  "Surv_months")) {
    merged_df <- rbind(clin_data1[c("consensuscluster", vars)],
                       clin_data2[c("consensuscluster", vars)],
                       clin_data3[c("consensuscluster", vars)])
    colnames(merged_df) <- c("consensuscluster",
                             "vars")
    
    plt <- ggboxplot(merged_df, 
                  x="consensuscluster",
                  y="vars",
                  color = "consensuscluster",
                  ggtheme = theme_gray(),
                  add='jitter') +
                  stat_compare_means() +
                  labs(title = as.character(vars)) +
                  xlab("Cluster") + ylab(vars)
                  
  }
  
  print(plt)
}

```


## SURVIVAL PLOT

### Survival curves from Kaplan-Meier analysis

The Kaplan–Meier estimator, also known as the product limit estimator, is a non-parametric statistic used to estimate the survival function from lifetime data. In medical research, it is often used to measure the fraction of patients living for a certain amount of time after treatment.
```{r}
library("survminer")
require("survival")

# survival in days
fit_days <-
  survfit(Surv(Surv_days, Surv_event) ~ consensuscluster, data = RNA_clin_data)
# survival in months
fit_months <-
  survfit(Surv(Surv_months, Surv_event) ~ consensuscluster, data = RNA_clin_data)
```

Plot both survival plots
```{r}
ggsurvplot(fit_days, data = RNA_clin_data)
ggsurvplot(fit_months, data = RNA_clin_data)
```

Look at the statistical information of the monthly survival plot
```{r}
res.sum <- surv_summary(fit_months)
res.sum
```

### Survival curves from Cox Proportional Hazards Model

```{r}
# Fit Cox Model
cox <-
  coxph(Surv(Surv_months, Surv_event) ~ strata(consensuscluster),
        data = RNA_clin_data)

summary(cox)
```

```{r}
library(simPH)

# Find predicted values
coxFit <- survfit(cox)

# Plot strata in a grid
ggfitStrata(coxFit, byStrata = TRUE, xlab = "Months")

# Plot all in one
ggfitStrata(coxFit, byStrata = FALSE, xlab = "Months")
```

But is there a more systematic way to look at the different covariates? As you might remember from one of the previous passages, Cox proportional hazards models allow you to include covariates. You can build Cox proportional hazards models using the coxph function and visualize them using the ggforest. These type of plot is called a forest plot. It shows so-called hazard ratios (HR) which are derived from the model for all covariates that we included in the formula in coxph. Briefly, an HR > 1 indicates an increased risk of death (according to the definition of h(t)) if a specific condition is met by a patient. An HR < 1, on the other hand, indicates a decreased risk.
```{r}
library("ggplot2")
library("survminer")
library("survival")

# Fit a Cox proportional hazards model
fit.coxph <- coxph(Surv(Surv_months, Surv_event) ~ consensuscluster, data = RNA_clin_data)

ggforest(fit.coxph, data = RNA_clin_data)
```

```{r}
summary(fit.coxph)
```

TODO try excluding the samples that are intercluster

## Significance tests on clinical information

Take a look at the clinical data
```{r}
RNA_clin_data[0:10, clinical_vars_names] 
```

## Statistical tests on clinical data
```{r}
# Loading the required package for percentage tables
library(RcmdrMisc)
```

**Functions for statistical tests**

Function to perform chi-squared test for the categorical variables of the clusters and identify which labels are significant.
```{r}
chi_squared_clusters <- function(variable_name, clinical_df) {
  ## Saving the possible outcomes of the feature
  mut_chisq_test_names <- c()
  variable_to_check <- variable_name
  values_to_check <- unique(clinical_df[,variable_name])
  values_to_check <- values_to_check[is.na(values_to_check) != TRUE]
  
  final_results <- c()
  
  for (value in c(values_to_check)) {
    cluster1_no <-
      length(which(
        clinical_df[, variable_to_check] == value &
          clinical_df[, "consensuscluster"] == 1 &
          is.na(clinical_df[, variable_to_check]) != TRUE
      ))
    cluster2_no <-
      length(which(
        clinical_df[, variable_to_check] == value &
          clinical_df[, "consensuscluster"] == 2 &
          is.na(clinical_df[, variable_to_check]) != TRUE
      ))
    cluster3_no <-
      length(which(
        clinical_df[, variable_to_check] == value &
          clinical_df[, "consensuscluster"] == 3 &
          is.na(clinical_df[, variable_to_check]) != TRUE
      ))
    
    
    cluster1 <-
      length(which(
        clinical_df[, variable_to_check] != value &
          clinical_df[, "consensuscluster"] == 1 &
          is.na(clinical_df[, variable_to_check]) != TRUE
      ))
    cluster2 <-
      length(which(
        clinical_df[, variable_to_check] != value &
          clinical_df[, "consensuscluster"] == 2 &
          is.na(clinical_df[, variable_to_check]) != TRUE
      ))
    cluster3 <-
      length(which(
        clinical_df[, variable_to_check] != value &
          clinical_df[, "consensuscluster"] == 3 &
          is.na(clinical_df[, variable_to_check]) != TRUE
      ))
    
    df <-
      data.frame(
        cluster1 = c(0, 0),
        cluster2 = c(0, 0),
        cluster3 = c(0, 0)
      )
    
    
    df$cluster1 <- c(cluster1_no, cluster1)
    df$cluster2 <- c(cluster2_no, cluster2)
    df$cluster3 <- c(cluster3_no, cluster3)
    
    rownames(df) <- c("0", "1")
    
    chisq_test_var <- chisq.test(df, simulate.p.value = T)
    mut_chisq_test <- c(chisq_test_var$p.value)
    
    ## CALCULATING EFFECT SIZE
    # Custom function
    Cramers_V <- function(chi, n, df_es)
      sqrt((chi) / (n * df_es))
    # Find degrees of freedom - min row or col - 1
    df_es <- min(dim(df)) - 1
    # Calculate
    effect_size <-
      Cramers_V(chi = chisq_test_var$statistic,
                n = sum(df),
                df = df_es)
    
    # we save the P values and FDR of each test
    mut_chisq_test <-
      cbind(mut_chisq_test,
            p.adjust(mut_chisq_test),
            effect_size,
            df_es)
    colnames(mut_chisq_test) <-
      c("p_value", "fdr", "effect_size", "DOF")
    
    # we order the resulting matrix by P value
    if (mut_chisq_test[1]<0.05) {
      final_results[[value]] <- mut_chisq_test
    }
  }
  return(final_results)
}
```

Function to perform the Kruskal-Wallis test on the categorical variables and get a global value of significance. At the same time, the chi-square function is run to understand which labels are the most significant.
```{r}
categorical_kruskal_wallis_test <-
  function(variable_name, clinical_df, formula) {
    print(variable_name)
    print("---")
    print("Calculating the frequencies per cluster...")
    # Calculate the frequencies of each class into each cluster
    temp_table <-
      table(clinical_df[c(variable_name, "consensuscluster")])
    
    # counts
    print("counts")
    print(temp_table)
    
    # percentage
    print("percentages")
    print(colPercents(temp_table, 2))
    
    # --------------
    # Kruskal-Wallis test (is the variable significant?)
    kruskal_wallis_general <-
      kruskal.test(formula, data = clinical_df)
    print(kruskal_wallis_general)
    
    # Chi-squared test
    chisq_test_res <-
      chi_squared_clusters(variable_name, clinical_df)
    
    return(chisq_test_res)
  }
```

Function to perform logistic regression on the numeric variables and return the significance of each pair of clusters variables.
```{r}
clinical_test <-
  function(variable_name,
           clinical_df,
           formula,
           predictor_type) {
    print(variable_name)
    print("---")
    print("Running logistic regression per each cluster combination...")
    
    # Removing rows with missing values
    clinical_df_nonull <-
      clinical_df[!is.na(clinical_df[, variable_name]),]
    
    # Logistic regression on each possible cluster combination
    significant_excluding <- c()
    for (cluster in 1:3) {
      model <-
        glm(formula = formula,
            data = clinical_df_nonull[clinical_df_nonull$consensuscluster != cluster, ],
            family = binomial)
      significant_excluding[[as.numeric(cluster)]] <-
        cbind(summary(model)$coeff[-1, 4], summary(model)$coeff[-1, 4] < 0.05)
    }
    print(significant_excluding)
    if (predictor_type == "categorical") {
      print("Running Kruskal Wallis test and Chi-square test for independence...")
      categorical_kruskal_wallis_test(
        variable_name = variable_name,
        clinical_df = clinical_df_nonull,
        formula = formula
      )
    }
    else if (predictor_type == "numerical") {
      print("Running ANOVA test...")
      
      aov_variable <-
        aov(clinical_df_nonull[, variable_name] ~ clinical_df_nonull$consensuscluster)
      print(variable_name)
      print(summary(aov_variable))
    }
  }
```


**Numeric variables**

Running the statistical tests for the numerical variables

Age
```{r}
clinical_test(
  variable_name = "age",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ age,
  predictor_type = "numerical"
)

# Undo the feature scaling for easier interpretation of the data
RNA_clin_data_orig <- RNA_clin_data
RNA_clin_data_orig$age <- RNA_clin_data_orig$age ^ 2

group_by(RNA_clin_data_orig[!is.na(RNA_clin_data_orig[, "age"]), ], RNA_clin_data[!is.na(RNA_clin_data_orig[, "age"]), "consensuscluster"]) %>%
  summarise(
    count = n(),
    mean = mean(age, na.rm = TRUE),
    sd = sd(age, na.rm = TRUE)
  )

ggplot(RNA_clin_data_orig, aes(y = age)) +
  geom_boxplot(
    aes(color = consensuscluster, fill = consensuscluster),
    bins = 30,
    alpha = 0.3,
    outlier.size = 2,
    outlier.colour = "black"
  )

```
For the age, the cluster 1 is significant compared to the other two clusters, including younger people (mean age ~52) compared to cluster 2 and 3 (mean age ~55).

Tumor size mm
```{r}
clinical_test(
  variable_name = "tumor_size_mm",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ tumor_size_mm,
  predictor_type = "numerical"
)

# Undo the feature scaling for easier interpretation of the data
RNA_clin_data_orig <- RNA_clin_data
RNA_clin_data_orig$tumor_size_mm <- RNA_clin_data_orig$tumor_size_mm ^ 2

group_by(RNA_clin_data_orig[!is.na(RNA_clin_data_orig[, "tumor_size_mm"]), ], RNA_clin_data[!is.na(RNA_clin_data_orig[, "tumor_size_mm"]), "consensuscluster"]) %>%
  summarise(
    count = n(),
    mean = mean(tumor_size_mm, na.rm = TRUE),
    sd = sd(tumor_size_mm, na.rm = TRUE)
  )

ggplot(RNA_clin_data_orig, aes(y = tumor_size_mm)) +
  geom_boxplot(
    aes(color = consensuscluster, fill = consensuscluster),
    bins = 30,
    alpha = 0.3,
    outlier.size = 2,
    outlier.colour = "black"
  )

```
For the tumor size in mm, none of the cluster comparisons show significance, with all of the means ranging between ~25-30 mm.


relapse_free_months
```{r}
clinical_test(
  variable_name = "relapse_free_months",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ relapse_free_months,
  predictor_type = "numerical"
)

# Undo the feature scaling for easier interpretation of the data
RNA_clin_data_orig <- RNA_clin_data
RNA_clin_data_orig$relapse_free_months <- RNA_clin_data_orig$relapse_free_months ^ 2

group_by(RNA_clin_data_orig[!is.na(RNA_clin_data_orig[, "relapse_free_months"]), ], RNA_clin_data[!is.na(RNA_clin_data_orig[, "relapse_free_months"]), "consensuscluster"]) %>%
  summarise(
    count = n(),
    mean = mean(relapse_free_months, na.rm = TRUE),
    sd = sd(relapse_free_months, na.rm = TRUE)
  )

ggplot(RNA_clin_data_orig, aes(y = relapse_free_months)) +
  geom_boxplot(
    aes(color = consensuscluster, fill = consensuscluster),
    bins = 30,
    alpha = 0.3,
    outlier.size = 2,
    outlier.colour = "black"
  )

```
For the relapse free months, none of the cluster comparisons show significance, with a mean ranging from ~95-115 months.

Surv_months
```{r}
clinical_test(
  variable_name = "Surv_months",
  clinical_df =  RNA_clin_data[!is.na(RNA_clin_data[, "Surv_months"]), ],
  formula = consensuscluster ~ Surv_months,
  predictor_type = "numerical"
)

# Undo the feature scaling for easier interpretation of the data
RNA_clin_data_orig <- RNA_clin_data
RNA_clin_data_orig$Surv_months <- RNA_clin_data_orig$Surv_months ^ 2

group_by(RNA_clin_data_orig[!is.na(RNA_clin_data_orig[, "Surv_months"]), ], RNA_clin_data[!is.na(RNA_clin_data_orig[, "Surv_months"]), "consensuscluster"]) %>%
  summarise(
    count = n(),
    mean = mean(Surv_months, na.rm = TRUE),
    sd = sd(Surv_months, na.rm = TRUE)
  )

ggplot(RNA_clin_data_orig, aes(y = Surv_months)) +
  geom_boxplot(
    aes(color = consensuscluster, fill = consensuscluster),
    bins = 30,
    alpha = 0.3,
    outlier.size = 2,
    outlier.colour = "black"
  )

```
For the survival months, the cluster 2 indicates a survival significance against cluster 1 and 2. The cluster 2 is associated with lower survival months (mean of ~72 months), compared to cluster 1 (mean of ~97 months) and cluster 3 (mean of ~103 months).

Surv_days
```{r}
clinical_test(
  variable_name = "Surv_days",
  clinical_df =  RNA_clin_data[!is.na(RNA_clin_data[, "Surv_days"]), ],
  formula = consensuscluster ~ Surv_days,
  predictor_type = "numerical"
)

# Undo the feature scaling for easier interpretation of the data
RNA_clin_data_orig <- RNA_clin_data
RNA_clin_data_orig$Surv_days <- RNA_clin_data_orig$Surv_days ^ 2

group_by(RNA_clin_data_orig[!is.na(RNA_clin_data_orig[, "Surv_days"]), ], RNA_clin_data[!is.na(RNA_clin_data_orig[, "Surv_days"]), "consensuscluster"]) %>%
  summarise(
    count = n(),
    mean = mean(Surv_days, na.rm = TRUE),
    sd = sd(Surv_days, na.rm = TRUE)
  )

ggplot(RNA_clin_data_orig, aes(y = Surv_days)) +
  geom_boxplot(
    aes(color = consensuscluster, fill = consensuscluster),
    bins = 30,
    alpha = 0.3,
    outlier.size = 2,
    outlier.colour = "black"
  )

```
For the survival months, the cluster 2 indicates a survival significance against cluster 1 and 2. The cluster 2 is associated with lower survival months (mean of ~72 months), compared to cluster 1 (mean of ~97 months) and cluster 3 (mean of ~103 months).


**Categorical variables**

histological_grade
```{r}
clinical_test(
  variable_name = "histological_grade",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ histological_grade,
  predictor_type = "categorical"
)

temp_table <-
  table(RNA_clin_data[!is.na(RNA_clin_data[, "histological_grade"]), c("histological_grade", "consensuscluster")])

# counts
temp_table

# percentage
colPercents(temp_table, 2)

tab_var <-
  table(RNA_clin_data[, c('consensuscluster', 'histological_grade')])
plt <-
  barplot(
    tab_var,
    legend.text = c('cluster1', 'cluster2', 'cluster3'),
    xlab = "histological_grade",
    ylab = "counts"
  )
print(plt)

plt_prop <- ggplot(RNA_clin_data,
                   aes(x = consensuscluster,
                       fill = histological_grade)) +
  geom_bar(position = "fill") +
  labs(y = "Proportion")
print(plt_prop)

```
The histological grade shows significance on the non-parametric tests with p-values < 0.05, even though the logistic regression model didn't provide the same results. Visualizing the distributions per cluster, the cluster 3 shows a higher relative percentage of histological type 2 patients (68%) compared to cluster 1 and 2 (~10%).

vital_status
```{r}
clinical_test(
  variable_name = "vital_status",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ vital_status,
  predictor_type = "categorical"
)

temp_table <-
  table(RNA_clin_data[!is.na(RNA_clin_data[, "vital_status"]), c("vital_status", "consensuscluster")])

# counts
temp_table

# percentage
colPercents(temp_table, 2)

tab_var <-
  table(RNA_clin_data[, c('consensuscluster', 'vital_status')])
plt <-
  barplot(
    tab_var,
    legend.text = c('cluster1', 'cluster2', 'cluster3'),
    xlab = "vital_status",
    ylab = "counts"
  )
print(plt)

plt_prop <- ggplot(RNA_clin_data,
                   aes(x = consensuscluster,
                       fill = vital_status)) +
  geom_bar(position = "fill") +
  labs(y = "Proportion")
print(plt_prop)

```
The vital status shows significance with p-values < 0.05. One of the most significant difference between cluster 2 and cluster 3 is the % of living patients, where cluster 2 has a higher % of living people (24%) compared to cluster 3 (~40%). On the other hand, the most significant differences between cluster 1 and cluster 2 is the % of living patients and the % of people that died of disease, where cluster 1 has a higher chance of dying of disease and of living (in general).


histological_type
```{r}
clinical_test(
  variable_name = "histological_type",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ histological_type,
  predictor_type = "categorical"
)

temp_table <-
  table(RNA_clin_data[!is.na(RNA_clin_data[, "histological_type"]), c("histological_type", "consensuscluster")])

# counts
temp_table

# percentage
colPercents(temp_table, 2)

tab_var <-
  table(RNA_clin_data[, c('consensuscluster', 'histological_type')])
plt <-
  barplot(
    tab_var,
    legend.text = c('cluster1', 'cluster2', 'cluster3'),
    xlab = "histological_type",
    ylab = "counts"
  )
print(plt)

plt_prop <- ggplot(RNA_clin_data,
                   aes(x = consensuscluster,
                       fill = histological_type)) +
  geom_bar(position = "fill") +
  labs(y = "Proportion")
print(plt_prop)

```
The histological type shows significance with p-values < 0.05 between cluster 2 vs 3 and cluster 1 vs 3 on histological type == "Lobular" and "Mixed". Cluster 3 has a lower percentage of Ductal cases compared to the other two clusters.


tumor stage
```{r}
clinical_test(
  variable_name = "tumor_stage",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ tumor_stage,
  predictor_type = "categorical"
)

temp_table <-
  table(RNA_clin_data[!is.na(RNA_clin_data[, "tumor_stage"]), c("tumor_stage", "consensuscluster")])

# counts
temp_table

# percentage
colPercents(temp_table, 2)

tab_var <-
  table(RNA_clin_data[, c('consensuscluster', 'tumor_stage')])
plt <-
  barplot(
    tab_var,
    legend.text = c('cluster1', 'cluster2', 'cluster3'),
    xlab = "tumor_stage",
    ylab = "counts"
  )
print(plt)

plt_prop <- ggplot(RNA_clin_data,
                   aes(x = consensuscluster,
                       fill = tumor_stage)) +
  geom_bar(position = "fill") +
  labs(y = "Proportion")
print(plt_prop)

```
The tumor stage shows significance with p-values < 0.05 between cluster 1 vs cluster 3. Cluster 3 has a higher percentage of stage 2 cases (68%) compared to the cluster 3 (47%).


Relapse
```{r}
clinical_test(
  variable_name = "Relapse",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ Relapse,
  predictor_type = "categorical"
)

temp_table <-
  table(RNA_clin_data[!is.na(RNA_clin_data[, "Relapse"]), c("Relapse", "consensuscluster")])

# counts
temp_table

# percentage
colPercents(temp_table, 2)

tab_var <-
  table(RNA_clin_data[, c('consensuscluster', 'Relapse')])

plt <-
  barplot(
    tab_var,
    legend.text = c('cluster1', 'cluster2', 'cluster3'),
    xlab = "Relapse",
    ylab = "counts"
  )
print(plt)

plt_prop <- ggplot(RNA_clin_data,
                   aes(x = consensuscluster,
                       fill = Relapse)) +
  geom_bar(position = "fill") +
  labs(y = "Proportion")
print(plt_prop)

```
The Relapse variable shows no significance among clusters.


menopausal_state
```{r}
clinical_test(
  variable_name = "menopausal_state",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ menopausal_state,
  predictor_type = "categorical"
)

temp_table <-
  table(RNA_clin_data[!is.na(RNA_clin_data[, "menopausal_state"]), c("menopausal_state", "consensuscluster")])

# counts
temp_table

# percentage
colPercents(temp_table, 2)

tab_var <-
  table(RNA_clin_data[, c('consensuscluster', 'menopausal_state')])

plt <-
  barplot(
    tab_var,
    legend.text = c('cluster1', 'cluster2', 'cluster3'),
    xlab = "menopausal_state",
    ylab = "counts"
  )
print(plt)

plt_prop <- ggplot(RNA_clin_data,
                   aes(x = consensuscluster,
                       fill = menopausal_state)) +
  geom_bar(position = "fill") +
  labs(y = "Proportion")
print(plt_prop)

```
The cluster 3 has a higher percentage of post-menopausal patients (75%) compared to cluster 1 (56%).

chemotherapy
```{r}
clinical_test(
  variable_name = "chemotherapy",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ chemotherapy,
  predictor_type = "categorical"
)

temp_table <-
  table(RNA_clin_data[!is.na(RNA_clin_data[, "chemotherapy"]), c("chemotherapy", "consensuscluster")])

# counts
temp_table

# percentage
colPercents(temp_table, 2)

tab_var <-
  table(RNA_clin_data[, c('consensuscluster', 'chemotherapy')])

plt <-
  barplot(
    tab_var,
    legend.text = c('cluster1', 'cluster2', 'cluster3'),
    xlab = "chemotherapy",
    ylab = "counts"
  )
print(plt)

plt_prop <- ggplot(RNA_clin_data,
                   aes(x = consensuscluster,
                       fill = chemotherapy)) +
  geom_bar(position = "fill") +
  labs(y = "Proportion")
print(plt_prop)

```
The cluster 1 has a higher percentage of patients treated with chemotherapy (61%) compared to cluster 1 (45%).

radiotherapy
```{r}
clinical_test(
  variable_name = "radiotherapy",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ radiotherapy,
  predictor_type = "categorical"
)

temp_table <-
  table(RNA_clin_data[!is.na(RNA_clin_data[, "radiotherapy"]), c("radiotherapy", "consensuscluster")])

# counts
temp_table

# percentage
colPercents(temp_table, 2)

tab_var <-
  table(RNA_clin_data[, c('consensuscluster', 'radiotherapy')])

plt <-
  barplot(
    tab_var,
    legend.text = c('cluster1', 'cluster2', 'cluster3'),
    xlab = "radiotherapy",
    ylab = "counts"
  )
print(plt)

plt_prop <- ggplot(RNA_clin_data,
                   aes(x = consensuscluster,
                       fill = radiotherapy)) +
  geom_bar(position = "fill") +
  labs(y = "Proportion")
print(plt_prop)

```
The cluster 1 has a higher percentage of patients treated with radiotherapy (77%) compared to cluster 1 (65%).


hormone_therapy
```{r}
clinical_test(
  variable_name = "hormone_therapy",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ hormone_therapy,
  predictor_type = "categorical"
)

temp_table <-
  table(RNA_clin_data[!is.na(RNA_clin_data[, "hormone_therapy"]), c("hormone_therapy", "consensuscluster")])

# counts
temp_table

# percentage
colPercents(temp_table, 2)

tab_var <-
  table(RNA_clin_data[, c('consensuscluster', 'hormone_therapy')])

plt <-
  barplot(
    tab_var,
    legend.text = c('cluster1', 'cluster2', 'cluster3'),
    xlab = "hormone_therapy",
    ylab = "counts"
  )
print(plt)

plt_prop <- ggplot(RNA_clin_data,
                   aes(x = consensuscluster,
                       fill = hormone_therapy)) +
  geom_bar(position = "fill") +
  labs(y = "Proportion")
print(plt_prop)

```
There is recorded significance for the hormone therapy values between cluster 2 vs cluster 3, and cluster 1 vs cluster 3. The cluster 3 presents the highest percentage of patients treated with hormone therapy (60%) compared to the other two clusters (~21-26%).


relapse_free_status
```{r}
clinical_test(
  variable_name = "relapse_free_status",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ relapse_free_status,
  predictor_type = "categorical"
)

temp_table <-
  table(RNA_clin_data[!is.na(RNA_clin_data[, "relapse_free_status"]), c("relapse_free_status", "consensuscluster")])

# counts
temp_table

# percentage
colPercents(temp_table, 2)

tab_var <-
  table(RNA_clin_data[, c('consensuscluster', 'relapse_free_status')])

plt <-
  barplot(
    tab_var,
    legend.text = c('cluster1', 'cluster2', 'cluster3'),
    xlab = "relapse_free_status",
    ylab = "counts"
  )
print(plt)

plt_prop <- ggplot(RNA_clin_data,
                   aes(x = consensuscluster,
                       fill = relapse_free_status)) +
  geom_bar(position = "fill") +
  labs(y = "Proportion")
print(plt_prop)

```
The relapse free status variable shows no significance among clusters.

Surv event
```{r}
clinical_test(
  variable_name = "Surv_event",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ Surv_event,
  predictor_type = "categorical"
)

temp_table <-
  table(RNA_clin_data[!is.na(RNA_clin_data[, "Surv_event"]), c("Surv_event", "consensuscluster")])

# counts
temp_table

# percentage
colPercents(temp_table, 2)

tab_var <-
  table(RNA_clin_data[, c('consensuscluster', 'Surv_event')])

plt <-
  barplot(
    tab_var,
    legend.text = c('cluster1', 'cluster2', 'cluster3'),
    xlab = "Surv_event",
    ylab = "counts"
  )
print(plt)

plt_prop <- ggplot(RNA_clin_data,
                   aes(x = consensuscluster,
                       fill = Surv_event)) +
  geom_bar(position = "fill") +
  labs(y = "Proportion")
print(plt_prop)

```
The survival event variable shows no significance among clusters.

## Mutations Analysis

Download the mutations from the available sources. 

Ref 2 mutations
```{r}
mut_Ref2 <-
  read.delim(
    file = "~/TNBC_Research/data/mutations_files/Ref2_mutations.txt",
    sep = "\t",
    header = T,
    stringsAsFactors = F,
    skip = 1
  )

mut_Ref2[0:10, 0:10]
```

Ref 4 mutations
```{r}
mut_Ref4 <-
  read.delim(
    file = "~/TNBC_Research/data/mutations_files/Ref4_mutations.txt",
    sep = "\t",
    header = T,
    stringsAsFactors = F,
    skip = 0
  )

mut_Ref4[0:10, 0:10]
```

TCGA mutations
```{r}
mut_TCGA <-
  read.delim(
    file = "~/TNBC_Research/data/mutations_files/TCGA_mutations.maf.txt",
    sep = "\t",
    header = T,
    stringsAsFactors = F
  )

mut_TCGA[0:10, 0:10]
```

Merging the mutation datasets
```{r}
# Columns in common with all the mutation datasets
merged_mut_cols <- intersect(colnames(mut_Ref2), colnames(mut_Ref4))
merged_mut_cols <- intersect(merged_mut_cols, colnames(mut_TCGA))

# Merged mutation datasets
merged_mut <-
  rbind(mut_Ref2[merged_mut_cols], mut_Ref4[merged_mut_cols])
merged_mut <- rbind(merged_mut, mut_TCGA[merged_mut_cols])

merged_mut[0:10, 0:10]
```

We check the data frame dimensions
```{r}
dim(merged_mut)
```

We drop mutations related to: UTR, introns, RNA and silent.
```{r}
mut_filters <-
  c("3'UTR",
    "5'Flank",
    "3'Flank",
    "5'UTR",
    "IGR",
    "Intron",
    "Silent",
    "RNA")
mut_filter_index <-
  which(merged_mut$Variant_Classification %in% mut_filters)
merged_mut <- merged_mut[-mut_filter_index, ]

dim(merged_mut)
```

We can observe the type of mutation in the column "Variant_Classification"
```{r}
table(merged_mut$Variant_Classification)[0:10]
```
We obtain the different samples and genes to make an array where it will store 0 and 1 depending on whether
mutation is present.
```{r}
u_samples <- sort(unique(merged_mut$Tumor_Sample_Barcode))
u_genes <- sort(unique(merged_mut$Hugo_Symbol))
mut_matrix <-
  matrix(
    0,
    nrow = length(u_genes),
    ncol = length(u_samples),
    
    dimnames = list(u_genes, u_samples)
  )

mut_matrix[1:5, 1:5]

mut_matrix <- mut_matrix[, -1]

mut_matrix[1:5, 1:5]
```

We fill the array by doing one loop per sample
```{r}
for(i in colnames(mut_matrix)) {
  aux_genes <-
    merged_mut$Hugo_Symbol[which(merged_mut$Tumor_Sample_Barcode == i)]
  mut_matrix[aux_genes, i] <- 1
}
```


Defining the cluster groups with the patient IDs
```{r}
library(dplyr)
k_clusters = 3
cluster = list()

for (i in seq(1, k_clusters)) {
  cluster[[i]] <- filter(annon, annon$consensuscluster == i)
}
```

We observe the difference in the naming convention of mutations and rna-seq data, as well as the difference in dimensions. We can compare the first 16 characters.
```{r}
raw_brca_rnaseq <- RNA_seq_merged

mut_rnaseq_match <- match(gsub(
  pattern = "-",
  replacement = "\\.",
  x = substr(colnames(mut_matrix), 1, 16)
),
substr(rownames(raw_brca_rnaseq), 1, 16))

mut_rnaseq_match[0:10]
```

Clean the mutation matrix and expression matrix from NA values
```{r}
raw_brca_rnaseq <- t(RNA_seq_merged)

# to store the non NA values postitions
mut_rnaseq_match_nonNA <- which(!is.na(mut_rnaseq_match))

# to remove the NA values from mut_matrix_rna and mut_rnaseq_match
mut_matrix_rna <- mut_matrix[, mut_rnaseq_match_nonNA]
mut_rnaseq_match <- mut_rnaseq_match[mut_rnaseq_match_nonNA]

rna_mut <- raw_brca_rnaseq[, mut_rnaseq_match]

cbind(colnames(mut_matrix_rna)[c(1, 20, 50, 54)],
      colnames(rna_mut)[c(1, 20, 50, 54)])
```

We filter the genes in RNA-seq that show no variation and we keep the most frequent mutations only.
```{r}
# We convert all the dataframe as numeric
rna_mut <-
  mutate_all(data.frame(rna_mut), function(x)
    as.numeric(as.character(x)))

# We apply the mad function
rna_mut_mad <- apply(rna_mut, 1, mad)
mad_zero <- which(rna_mut_mad == 0)
rna_mut <- rna_mut[-mad_zero, ]
table(apply(mut_matrix_rna, 1, sum))
```

We count the times each mutation appears in the matrix and store the ones with an appearance of >9 times
```{r}
# We count the times each mutation appears in the matrix
mut_matrix_rna_count <- apply(mut_matrix_rna, 1, sum)

# if the mutation count is greater than 9, we add it to the mut_matrix_rna
mut_matrix_rna <- mut_matrix_rna[which(mut_matrix_rna_count > 9), ]

mut_matrix_rna[0:10, 0:10]
```

### T-test mutations merged

We run a t-test to know which genes change according to the mutations
```{r}
mut_rna_test <- c()
mut_rna_test_names <- c()
for (i in 1:nrow(mut_matrix_rna)) {
  # we apply the function "function(x)" to each of the row values of rna_mut where each row value is x
  aux_mut_test <- t(sapply(1:nrow(rna_mut), function(x) {
    # mutation: the mutation row (presence or absence of mutation per gene sequence)
    # exp: the gene row of the rna_mut matrix
    aux_test <-
      t.test(
        formula = exp ~ mut,
        data = data.frame(mut = mut_matrix_rna[i, ],
                          exp = as.matrix(rna_mut)[x, ])
      )
    
    
    aux_test$p.value
  }))
  
  # appending each test into a vector
  mut_rna_test <- c(mut_rna_test, aux_mut_test)
  # appending each name into a vector
  mut_rna_test_names <-
    c(mut_rna_test_names, paste(rownames(mut_matrix_rna)[i], rownames(rna_mut),
                                sep = "_"))
  
}

# we save the P values and FDR of each test
mut_rna_test <- cbind(mut_rna_test, p.adjust(mut_rna_test))
colnames(mut_rna_test) <- c("p_value", "fdr")
rownames(mut_rna_test) <- mut_rna_test_names

# we order the resulting matrix by P value
mut_rna_test <- mut_rna_test[order(mut_rna_test[, "p_value"]), ]
mut_rna_test[1:5, ]

```

Export the data frame with the p-values to a csv file
```{r}
mut_rna_test <- as.data.frame(mut_rna_test)
mut_rna_test$row_names <- rownames(mut_rna_test)

write.csv(
  as.data.frame(mut_rna_test),
  "C:\\Users\\victo\\OneDrive\\Documentos\\TNBC_research\\Clustering\\Mutations_merged_T_test.csv",
  row.names = FALSE
)
```

### Mtations per cluster
```{r}
mut_matrix_rna <- as.data.frame(mut_matrix_rna)
mut_matrix_rna[0:10,0:10]
```

```{r}
rna_mut[0:10,0:10]
```

```{r}
RNA_seq_merged <- as.data.frame(t(RNA_seq_merged))
RNA_seq_merged[0:10,0:10]
```
```{r}
colnames(RNA_seq_merged[,which(RNA_seq_merged["consensuscluster",] == 3)])[0:10]
```

```{r}
colnames(RNA_seq_merged[,which(RNA_seq_merged["consensuscluster",] == 2)])[0:10]
```

```{r}
colnames(RNA_seq_merged[,which(RNA_seq_merged["consensuscluster",] == 1)])[0:10]
```

```{r}
mut_rnaseq_match_cluster1 <-
  match(gsub(
    pattern = "-",
    replacement = "\\.",
    x = substr(colnames(rna_mut), 1, 16)
  ),
  substr(colnames(RNA_seq_merged[, which(RNA_seq_merged["consensuscluster",] == 1)]), 1, 16))

# to store the NA values postitions
NA_cluster1 <- which(is.na(mut_rnaseq_match_cluster1))

# to remove the NA values from mut_matrix_rna and mut_rnaseq_match
mut_matrix_rna_cluster1 <- mut_matrix_rna[,-NA_cluster1]
mut_rnaseq_match_cluster1 <- mut_rnaseq_match_cluster1[-NA_cluster1]
rna_mut_cluster1 <- rna_mut[-NA_cluster1]

print(dim(rna_mut_cluster1))
print(dim(mut_matrix_rna_cluster1))
```
```{r}
mut_rnaseq_match_cluster2 <-
  match(gsub(
    pattern = "-",
    replacement = "\\.",
    x = substr(colnames(rna_mut), 1, 16)
  ),
  substr(colnames(RNA_seq_merged[, which(RNA_seq_merged["consensuscluster",] == 2)]), 1, 16))

# to store the NA values postitions
NA_cluster2 <- which(is.na(mut_rnaseq_match_cluster2))

# to remove the NA values from mut_matrix_rna and mut_rnaseq_match
mut_matrix_rna_cluster2 <- mut_matrix_rna[,-NA_cluster2]
mut_rnaseq_match_cluster2 <- mut_rnaseq_match_cluster2[-NA_cluster2]
rna_mut_cluster2 <- rna_mut[-NA_cluster2]

print(dim(rna_mut_cluster2))
print(dim(mut_matrix_rna_cluster2))
```

```{r}
mut_rnaseq_match_cluster3 <-
  match(gsub(
    pattern = "-",
    replacement = "\\.",
    x = substr(colnames(rna_mut), 1, 16)
  ),
  substr(colnames(RNA_seq_merged[, which(RNA_seq_merged["consensuscluster",] == 3)]), 1, 16))

# to store the NA values postitions
NA_cluster3 <- which(is.na(mut_rnaseq_match_cluster3))

# to remove the NA values from mut_matrix_rna and mut_rnaseq_match
mut_matrix_rna_cluster3 <- mut_matrix_rna[,-NA_cluster3]
mut_rnaseq_match_cluster3 <- mut_rnaseq_match_cluster3[-NA_cluster3]
rna_mut_cluster3 <- rna_mut[-NA_cluster3]

print(dim(rna_mut_cluster3))
print(dim(mut_matrix_rna_cluster3))
```

### Chi2 mutations merged

We run a chi2 to know which genes change according to the mutations from cluster 1 vs cluster 2
```{r}
mut_rna_test <- c()
mut_rna_test_names <- c()
for (i in 1:nrow(mut_matrix_rna)) {
  # mutation: the mutation row (presence or absence of mutation per gene sequence)
  # exp: the gene row of the rna_mut matrix
  ones1 <- sum(mut_matrix_rna_cluster1[i,])
  zeros1 <- length(mut_matrix_rna_cluster1[i,]) - ones1
  
  ones2 <- sum(mut_matrix_rna_cluster2[i,])
  zeros2 <- length(mut_matrix_rna_cluster2[i,]) - ones2
  
  mut_clust <- as.table(rbind(c(zeros1, zeros2), c(ones1, ones2)))
  dimnames(mut_clust) <- list(status = c("No mutation", "Mutation"),
                              cluster = c("1", "2"))
  
  aux_mut_test <-
    chisq.test(mut_clust, simulate.p.value = T)$p.value
  
  # appending each test into a vector
  mut_rna_test <- c(mut_rna_test, aux_mut_test)
  # appending each name into a vector
  mut_rna_test_names <-
    c(mut_rna_test_names, paste(rownames(mut_matrix_rna)[i]))
}

# we save the P values and FDR of each test
mut_rna_test <- cbind(mut_rna_test, p.adjust(mut_rna_test))
colnames(mut_rna_test) <- c("p_value", "fdr")
rownames(mut_rna_test) <- mut_rna_test_names

# we order the resulting matrix by P value
mut_rna_test_12 <- as.data.frame(mut_rna_test[order(mut_rna_test[, "p_value"]),])

print("Significant mutations")
significant_mutations <-
  mut_rna_test_12[mut_rna_test_12$p_value < 0.05, ]
significant_mutations_names12 <- rownames(significant_mutations)
print(significant_mutations)

significant_mutations_values <-
  as.data.frame(cbind(
    rowSums(mut_matrix_rna_cluster1[significant_mutations_names12, ]),
    rowSums(mut_matrix_rna_cluster2[significant_mutations_names12, ])
  ))

colnames(significant_mutations_values) <-
  c("cluster 1", "cluster 2")
print(significant_mutations_values)
```
We run a chi2 to know which genes change according to the mutations from cluster 1 vs cluster 3
```{r}
mut_rna_test <- c()
mut_rna_test_names <- c()
for (i in 1:nrow(mut_matrix_rna)) {
  # mutation: the mutation row (presence or absence of mutation per gene sequence)
  # exp: the gene row of the rna_mut matrix
  ones1 <- sum(mut_matrix_rna_cluster1[i, ])
  zeros1 <- length(mut_matrix_rna_cluster1[i, ]) - ones1
  
  ones3 <- sum(mut_matrix_rna_cluster3[i, ])
  zeros3 <- length(mut_matrix_rna_cluster3[i, ]) - ones3
  
  mut_clust <- as.table(rbind(c(zeros1, zeros3), c(ones1, ones3)))
  dimnames(mut_clust) <- list(status = c("No mutation", "Mutation"),
                              cluster = c("1", "3"))
  
  aux_mut_test <- chisq.test(mut_clust, simulate.p.value = T)$p.value
  
  # appending each test into a vector
  mut_rna_test <- c(mut_rna_test, aux_mut_test)
  # appending each name into a vector
  mut_rna_test_names <-
    c(mut_rna_test_names, paste(rownames(mut_matrix_rna)[i]))
}

# we save the P values and FDR of each test
mut_rna_test <- cbind(mut_rna_test, p.adjust(mut_rna_test))
colnames(mut_rna_test) <- c("p_value", "fdr")
rownames(mut_rna_test) <- mut_rna_test_names

# we order the resulting matrix by P value
mut_rna_test_13 <- as.data.frame(mut_rna_test[order(mut_rna_test[, "p_value"]),])

print("Significant mutations")
significant_mutations <-
  mut_rna_test_13[mut_rna_test_13$p_value < 0.05, ]
significant_mutations_names13 <- rownames(significant_mutations)
print(significant_mutations)

significant_mutations_values <-
  as.data.frame(cbind(
    rowSums(mut_matrix_rna_cluster1[significant_mutations_names13, ]),
    rowSums(mut_matrix_rna_cluster3[significant_mutations_names13, ])
  ))

colnames(significant_mutations_values) <-
  c("cluster 1", "cluster 3")
print(significant_mutations_values)
```

We run a chi2 to know which genes change according to the mutations from cluster 2 vs cluster 3
```{r}
mut_rna_test <- c()
mut_rna_test_names <- c()
for (i in 1:nrow(mut_matrix_rna)) {
  # mutation: the mutation row (presence or absence of mutation per gene sequence)
  # exp: the gene row of the rna_mut matrix
  ones2 <- sum(mut_matrix_rna_cluster2[i, ])
  zeros2 <- length(mut_matrix_rna_cluster2[i, ]) - ones2
  
  ones3 <- sum(mut_matrix_rna_cluster3[i, ])
  zeros3 <- length(mut_matrix_rna_cluster3[i, ]) - ones3
  
  mut_clust <- as.table(rbind(c(zeros2, zeros3), c(ones2, ones3)))
  dimnames(mut_clust) <- list(status = c("No mutation", "Mutation"),
                              cluster = c("2", "3"))
  
  aux_mut_test <- chisq.test(mut_clust, simulate.p.value = T)$p.value
  
  # appending each test into a vector
  mut_rna_test <- c(mut_rna_test, aux_mut_test)
  # appending each name into a vector
  mut_rna_test_names <-
    c(mut_rna_test_names, paste(rownames(mut_matrix_rna)[i]))
}

# we save the P values and FDR of each test
mut_rna_test <- cbind(mut_rna_test, p.adjust(mut_rna_test))
colnames(mut_rna_test) <- c("p_value", "fdr")
rownames(mut_rna_test) <- mut_rna_test_names

# we order the resulting matrix by P value
mut_rna_test_23 <- as.data.frame(mut_rna_test[order(mut_rna_test[, "p_value"]),])

print("Significant mutations")
significant_mutations <-
  mut_rna_test_23[mut_rna_test_23$p_value < 0.05, ]
significant_mutations_names23 <- rownames(significant_mutations)
print(significant_mutations)

significant_mutations_values <-
  as.data.frame(cbind(
    rowSums(mut_matrix_rna_cluster2[significant_mutations_names23, ]),
    rowSums(mut_matrix_rna_cluster3[significant_mutations_names23, ])
  ))

colnames(significant_mutations_values) <-
  c("cluster 2", "cluster 3")
print(significant_mutations_values)
```

Export the data frame with the p-values to a csv file
```{r}
mut_rna_test_12 <- as.data.frame(mut_rna_test_12)
mut_rna_test_12$row_names <- rownames(mut_rna_test_12)

mut_rna_test_13 <- as.data.frame(mut_rna_test_13)
mut_rna_test_13$row_names <- rownames(mut_rna_test_13)

mut_rna_test_23 <- as.data.frame(mut_rna_test_23)
mut_rna_test_23$row_names <- rownames(mut_rna_test_23)

write.csv(
  as.data.frame(mut_rna_test_12),
  "~/TNBC_research/code/csv_and_objects/mutations/Mutations_clusters1vs2_Chi2_test.csv",
  row.names = FALSE
)

write.csv(
  as.data.frame(mut_rna_test_13),
  "~/TNBC_research/code/csv_and_objects/mutations/Mutations_clusters1vs3_Chi2_test.csv",
  row.names = FALSE
)

write.csv(
  as.data.frame(mut_rna_test_23),
  "~/TNBC_research/code/csv_and_objects/mutations/Mutations_clusters2vs3_Chi2_test.csv",
  row.names = FALSE
)
```

Comparing the differentially expressed genes between both clusters
```{r}
significant_mutations_all <- unique(
  c(
    significant_mutations_names12,
    significant_mutations_names13,
    significant_mutations_names23
  )
)

cc1 <- colSums(t(mut_matrix_rna_cluster1))
cc2 <- colSums(t(mut_matrix_rna_cluster2))
cc3 <- colSums(t(mut_matrix_rna_cluster3))

temp <-
  cbind(cc1[significant_mutations_all], cc2[significant_mutations_all], cc3[significant_mutations_all])

rownames(temp) <- significant_mutations_all
colnames(temp) <- c("cluster1", "cluster2", "cluster3")

print(temp)

plt <-
  barplot(
    t(temp),
    legend.text = c('cluster1', 'cluster2', 'cluster3'),
    xlab = "counts",
    horiz = T,
    las=2
  )

```

## DEGs (Differentially expressed genes among clusters)

TODO: Check the final results of the clusters expressions vs the resulting DEGs, we expect to have maximum one NA per row.
```{r}
library(limma)

design <- model.matrix( ~ 0 + RNA_clin_data$consensuscluster)
design[0:10, ]
```

```{r}
## the column names are a bit ugly, so we will rename
colnames(design) <- c("Cluster1", "Cluster2", "Cluster3")
design[0:10, ]
```

It has been demonstrated that our power to detect differential expression can be improved if we filter lowly-expressed genes prior to performing the analysis. Quite how one defines a gene being expressed may vary from experiment to experiment, so a cut-off that will work for all datasets is not feasible. Here we consider that around 50% of our genes will not be expressed, and use the median expression level as a cut-off.

```{r}
RNA_seq_exprs <-
  RNA_seq_merged_allgenes[which(rownames(RNA_seq_merged_allgenes) != "consensuscluster"),]
RNA_seq_exprs <-
  mutate_all(data.frame(RNA_seq_exprs), function(x)
    as.numeric(as.character(x)))

summary(RNA_seq_exprs[, 1:10])

## calculate median expression level
temp_median <- apply(RNA_seq_exprs, 2, median)
cutoff <- median(temp_median, na.rm = T)

## TRUE or FALSE for whether each gene is "expressed" in each sample
is_expressed <- RNA_seq_exprs > cutoff

## Identify genes expressed in more than 2 samples
keep <- colSums(is_expressed) > 2

## check how many genes are removed / retained.
table(keep)

## subset to just those expressed genes
RNA_seq_exprs <- RNA_seq_exprs[,row.names(as.data.frame(keep))]
```

The lmFit function is used to fit the model to the data. The result of which is to estimate the expression level in each of the groups that we specified.
```{r}
RNA_seq_exprs_no_consensuscluster <-
  t(RNA_seq_exprs)[!(row.names(t(RNA_seq_exprs)) %in% c("consensuscluster")), ]

## calculate relative array weights
aw <- arrayWeights(RNA_seq_exprs_no_consensuscluster, design)
aw[0:10]

fit <-
  limma::lmFit(RNA_seq_exprs_no_consensuscluster, design, weights = aw)
fit$coefficients[1:10, ]
```

In order to perform the differential analysis, we have to define the contrast that we are interested in. In our case we only have two groups and one contrast of interest. Multiple contrasts can be defined in the makeContrasts function.

```{r}
contrasts_c1c2 <- makeContrasts(Cluster1 - Cluster2, levels = design)
contrasts_c1c3 <-
  makeContrasts(Cluster1 - Cluster3, levels = design)
contrasts_c2c3 <-
  makeContrasts(Cluster2 - Cluster3, levels = design)

fitc1c2 <- contrasts.fit(fit, contrasts_c1c2)
fitc1c3 <- contrasts.fit(fit, contrasts_c1c3)
fitc2c3 <- contrasts.fit(fit, contrasts_c2c3)
```


Finally, apply the empirical Bayes’ step to get our differential expression statistics and p-values.
```{r}
fitc1c2 <- eBayes(fitc1c2)
fitc1c3 <- eBayes(fitc1c3)
fitc2c3 <- eBayes(fitc2c3)
```

We usually get our first look at the results by using the topTable command
```{r}
topTable(fitc1c2)
```
```{r}
topTable(fitc1c3)
```
```{r}
topTable(fitc2c3)
```

If we want to know how many genes are differentially-expressed overall we can use the decideTests function.

** Cluster1 - Cluster 2
```{r}
decideTests(fitc1c2)
```
```{r}
table(decideTests(fitc1c2))
```

** Cluster1 - Cluster 3
```{r}
decideTests(fitc1c3)
```
```{r}
table(decideTests(fitc1c3))
```

** Cluster2 - Cluster 3
```{r}
decideTests(fitc2c3)
```

```{r}
table(decideTests(fitc2c3))
```

### Further processing and visualisation of DE results
At the moment our results are not particularly easy to navigate as the only information to identify each gene is the identifier that the microarray manufacturer has assigned. Fortunately, the GEO entry contains extensive annotation that we can add. The annotation data can be retrieved with the fData function and we restrict to columns we are interested in using select.

For your own data, you will have to choose the columns that are of interest to you. You probably won’t have the same column headings used here.

Once an annotation data frame has been created, it can be assigned to our results.
```{r}
full_resultsc1c2 <- topTable(fitc1c2, number = Inf)
full_resultsc1c2 <- tibble::rownames_to_column(full_resultsc1c2, "ID")

full_resultsc1c3 <- topTable(fitc1c3, number = Inf)
full_resultsc1c3 <- tibble::rownames_to_column(full_resultsc1c3, "ID")

full_resultsc2c3 <- topTable(fitc2c3, number = Inf)
full_resultsc2c3 <- tibble::rownames_to_column(full_resultsc2c3, "ID")
```

The “Volcano Plot” function is a common way of visualising the results of a DE analysis. The x axis shows the log-fold change and the y axis is some measure of statistical significance, which in this case is the log-odds, or “B” statistic. A characteristic “volcano” shape should be seen.

First we create a data frame that we can visualise in ggplot2. Specifying the number argument to topTable creates a table containing test results from all genes. We also put the probe IDs as a column rather than row names.

The flexibility of ggplot2 allows us to automatically label points on the plot that might be of interest. For example, genes that meet a particular p-value and log fold-change cut-off. With the code below the values of p_cutoff and fc_cutoff can be changed as desired.

Furthermore, we can label the identity of some genes. Below we set a limit of the top “N” genes we want to label, and label each gene according to it’s Symbol.

```{r}
library(ggrepel)

## change according to your needs
p_cutoff <- 0.01
fc_cutoff <- 1.5
topN <- 20
```

Cluster 1 vs Cluster 2
```{r}
full_resultsc1c2 %>%
  mutate(Significant = p.adjust(P.Value, method="fdr") < p_cutoff, abs(logFC) > fc_cutoff) %>%
  mutate(Rank = 1:n(), Label = ifelse(Rank < topN, ID, "")) %>%
  ggplot(aes(
    x = logFC,
    y = -log10(P.Value),
    col = Significant,
    label = Label
  )) + geom_point() + geom_text_repel(col = "black")
```

Cluster 1 vs Cluster 3
```{r}
full_resultsc1c3 %>%
  mutate(Significant = p.adjust(P.Value, method="fdr") < p_cutoff, abs(logFC) > fc_cutoff) %>%
  mutate(Rank = 1:n(), Label = ifelse(Rank < topN, ID, "")) %>%
  ggplot(aes(
    x = logFC,
    y = -log10(P.Value),
    col = Significant,
    label = Label
  )) + geom_point() + geom_text_repel(col = "black")
```

Cluster 2 vs Cluster 3
```{r}
full_resultsc2c3 %>%
  mutate(Significant = p.adjust(P.Value, method="fdr") < p_cutoff, abs(logFC) > fc_cutoff) %>%
  mutate(Rank = 1:n(), Label = ifelse(Rank < topN, ID, "")) %>%
  ggplot(aes(
    x = logFC,
    y = -log10(P.Value),
    col = Significant,
    label = Label
  )) + geom_point() + geom_text_repel(col = "black")
```

We can filter according to p-value (adjusted) and fold-change cut-offs
```{r}
sign_genes_c1c2 <- filter(full_resultsc1c2, adj.P.Val < p_cutoff)
sign_genes_c1c3 <- filter(full_resultsc1c3, adj.P.Val < p_cutoff)
sign_genes_c2c3 <- filter(full_resultsc2c3, adj.P.Val < p_cutoff)
```

We save the results
```{r}
library(readr)
full_resultsc1c2 %>%
  write_csv(file="complete_DEGs_results_c1c2_18_sep_22.csv")

full_resultsc1c3 %>%
  write_csv(file="complete_DEGs_results_c1c3_18_sep_22.csv")

full_resultsc2c3 %>%
  write_csv(file="complete_DEGs_results_c2c3_18_sep_22.csv")
```


Comparing the diferentially expressed genes between all the clusters
```{r}
significant_genes <- filter(full_resultsc1c2, p.adjust(P.Value, method="fdr") < p_cutoff)$ID

cc1 <- colMeans(RNA_seq_exprs[RNA_seq_exprs$consensuscluster == 1])
cc2 <- colMeans(RNA_seq_exprs[RNA_seq_exprs$consensuscluster == 2])
cc3 <- colMeans(RNA_seq_exprs[RNA_seq_exprs$consensuscluster == 3])

temp <-
  cbind(cc1[significant_genes], cc2[significant_genes], cc3[significant_genes])

rownames(temp) <- significant_genes
colnames(temp) <- c("cluster1", "cluster2", "cluster3")

temp
```

### Heatmaps of selected genes

**Most differentially-expressed genes**
We have already created a table of differential expression results, which is ranked according to statistical significance.

To visualise the most differentially-expressed genes, we first need to extract their ID. These IDs should correspond to rows in the expression matrix.

In the code below we introduce a new column to the results which just gives a row number to each gene. We then filter to return data for the top N results. The pull function is used to extract the ID column as a variable.
```{r}
## Use to top 20 genes for illustration
topN <- 20

##
ids_of_interest12 <- mutate(full_resultsc1c2, Rank = 1:n()) %>%
  filter(Rank < topN) %>%
  pull(ID)
ids_of_interest13 <- mutate(full_resultsc1c3, Rank = 1:n()) %>%
  filter(Rank < topN) %>%
  pull(ID)
ids_of_interest23 <- mutate(full_resultsc2c3, Rank = 1:n()) %>%
  filter(Rank < topN) %>%
  pull(ID)
```

In order to label the heatmap in a useful manner we extract the corresponding gene symbols.
```{r}
gene_names12 <- mutate(full_resultsc1c2, Rank = 1:n()) %>% 
  filter(Rank < topN) %>% 
  pull(ID) 
gene_names13 <- mutate(full_resultsc1c3, Rank = 1:n()) %>% 
  filter(Rank < topN) %>% 
  pull(ID) 
gene_names23 <- mutate(full_resultsc2c3, Rank = 1:n()) %>% 
  filter(Rank < topN) %>% 
  pull(ID) 
```

The expression values for the IDs we have retrieved can be obtained by using the [..] notation to index the expression matrix.
```{r}
## Get the rows corresponding to ids_of_interest and all columns
gene_matrix12 <- t(RNA_seq_exprs)[ids_of_interest12,]
gene_matrix13 <- t(RNA_seq_exprs)[ids_of_interest13,]
gene_matrix23 <- t(RNA_seq_exprs)[ids_of_interest23,]
```

We now make the heatmap. A default colour scheme is used, but can be changed via the arguments. 
```{r}
pheatmap(gene_matrix12[,1:20],
     labels_row = gene_names,
     scale="row")
```
```{r}
pheatmap(gene_matrix13[,1:20],
     labels_row = gene_names,
     scale="row")
```
```{r}
pheatmap(gene_matrix23[,1:20],
     labels_row = gene_names,
     scale="row")
```
## PATHWAYS

First we get the genes set corresponding to the "homo sapiens" specie (human). 
```{r}
library(msigdbr)

human_gene_sets = msigdbr(species = "Homo sapiens", category = "H")
head(human_gene_sets)
```

Save the list of all the available gene symbols for the homo sapiens gene set
```{r}
m_list = human_gene_sets %>% split(x = .$gene_symbol, f = .$gs_name)
m_list
```

Take a look at the first rows of the normalized genes used for the clustering analysis.
```{r}
head(train_mad)
```


Filter the main genes dataframe to include only the genes mainly represented in each cluster.
```{r}
# Transform the m_list into a vector to perform the intersections
m_list_vector <-  unlist(m_list)

# All clusters intersection and filtering
intersecting_genes_all_clusters <-
  intersect(m_list_vector, rownames(train_mad))

genes_df_all_clusters <-
  train_mad[row.names(train_mad) %in% intersecting_genes_all_clusters, ]
```

# TODO
 -  Calcular score para cada muestra, sin importar si son significativos o no
 -  Comparacion entre clusters, no de cada uno de los clusters
 -  Input = Matriz de expresion de genes utilizada para el clustering
 
 - Survival sin sujetos intercluster

Now, lets explore the pathways for each cluster
```{r}
library(msigdbr)

# all genes
hallmarks_ssgsea_cluster <- GSVA::gsva(as.matrix(train_mad), 
                               gset.idx.list = m_list, 
                               method= "ssgsea",
                               verbose= FALSE)

```

```{r}
## fit the same linear model now to the GSVA enrichment scores
fit_gsea <- lmFit(hallmarks_ssgsea_cluster, design)
## estimate moderated t-statistics
fit_gsea <- eBayes(fit_gsea)
```

Clusters
```{r}
topTable(fit_gsea, coef="Cluster1")
topTable(fit_gsea, coef="Cluster2")
topTable(fit_gsea, coef="Cluster3")
```


