---
title: "TNBC Clustering (Gene expression, mutations, clinical data)"
author: "Victoria Rios"
date: "30/08/2022"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Data Analysis of TNBC gene expression information and mutations

***

## Import Libraries

Avoid strings being recognized as factors and import libraries used in the next chunks of code.
```{r}
options(stringsAsFactors = F)

# Import packages libraries
library(factoextra)
library(M3C)
library(plyr)
library(dplyr)

# Import local functions
source("~/TNBC_Research/code/general_functions.R")
```

## Import Data

### Expression data
Import resulting data frames containing gene expression data (previously normalized with log2 and batch effect assessed by ComBat), where each column is a sample and each row a gene.

characteristic      | train | train_mad 
rows (genes)        | 10856 | 2648   
columns (samples)   | 509   | 509

```{r}
# Read the csv files containing the dataframes
train <-
  read.csv("~/TNBC_Research/code/csv_and_objects/ComBat/ComBat.csv",
           row.names = "row.names")
train_mad <-
  read.csv("~/TNBC_Research/code/csv_and_objects/ComBat/ComBat_mad.csv",
           row.names = "row.names")

# Load the validation files containing the validation dataframes
load("~/TNBC_Research/data/db_files/Validation/TNBC_validation_dataset.RData")

# Observe the first records of the gene expression data frame
head(train_mad)
```


### Clinical data
Import the clinical information data frame that matches with the samples found in the genetic information data frame imported in the previous chunks of code (specifically "train_mad").
```{r}
# Read the csv file with the clinical information
RNA_clin_data <-
  read.csv(
    "~/TNBC_Research/code/csv_and_objects/ComBat/clinical_data_combat_mad.csv",
    row.names = "row.names"
  )

# Set ID as a new column (this will be used in the Consensus Clustering section of the analysis)
RNA_clin_data$ID <- row.names(RNA_clin_data)

# Observe the first records of the clinical information data frame
head(RNA_clin_data)
```

### Validation data cleaning and transformation
```{r}
head(gse142258_clin)
head(gse142731_clin)
head(gse163882_clin)

# Transforming
gse142258_clin <- t(gse142258_clin)
gse142258_clin <- as.data.frame(gse142258_clin)
gse142258_clin["Sample_description"] <- lapply(gse142258_clin["Sample_description"], gsub, pattern = "-", replacement = ".")
row.names(gse142258_clin) <- gse142258_clin$Sample_description
gse142258_clin$ID <- row.names(gse142258_clin)
gse142258_clin$source_db <- "gse142258"

gse142731_clin <- t(gse142731_clin)
gse142731_clin <- as.data.frame(gse142731_clin)
row.names(gse142731_clin) <- gse142731_clin$Sample_description
gse142731_clin$ID <- row.names(gse142731_clin)
gse142731_clin$source_db <- "gse142731"

gse163882_clin <- t(gse163882_clin)
gse163882_clin <- as.data.frame(gse163882_clin)
gse163882_clin$Age <- gse163882_clin$AGE
# Remove columns using select()
gse163882_clin <- gse163882_clin %>% 
  select(-c(AGE))
row.names(gse163882_clin) <- lapply(gse163882_clin["Sample_title"], gsub, pattern = "\\:.*", replacement = "")$Sample_title
gse163882_clin$ID <- row.names(gse163882_clin)
gse163882_clin$source_db <- "gse163882"


# Merging the dataframes
RNA_clin_data_val <- merge(gse142258_clin, gse142731_clin, all = TRUE)
RNA_clin_data_val <- merge(RNA_clin_data_val, gse163882_clin, all = TRUE)
row.names(RNA_clin_data_val) <- RNA_clin_data_val$ID
```


Verify the shapes of the imported data frames.
```{r}
library(glue)

glue("Train -> rows(genes): {nrow(train)}, columns(samples): {ncol(train)}")
glue("Train_mad -> rows(genes): {nrow(train_mad)}, columns(samples): {ncol(train_mad)}")
glue("RNA_clin_data -> rows(samples): {nrow(RNA_clin_data)}, columns(clinical variables): {ncol(RNA_clin_data)}")
```

***

## Data Engineering

### Clean Data

Once we have the data, we need to ensure that it is in a format that we can use to create a model or perform statistical tests.
```{r}
# Format for the expression data
str(train_mad[,1:5])

# Format for the clinical data
str(RNA_clin_data)
```
The expression data is numeric, which is the desired format for the analysis. For the clinical data, there are a couple modifications that are required for the correct performance of the analysis:
- age -> int
- methastasis -> boolean
- histological_grade -> int
- tumor_stage -> int
- chemotherapy -> boolean
- radiotherapy -> boolean
- hormone_therapy -> boolean
- relapse_free_status -> int
- hispanic -> boolean
- met_* -> boolean
- response_to_treatment -> int (mapping)
- tabaquism -> boolean
- pathological_history -> boolean
- family_pathological_hsitory -> boolean
- relapse -> boolean
- TNBC_status -> boolean


It is needed to perform feature engineering, specially on the categorical clinical features, since some of the classes are correlated or even duplicated among the set of unique labels per feature. A manual renaming of the classes is performed to account for this issue.
```{r}
# Define a vector with the names of the features to engineer
features_to_engineer <- c("histological_type",
                          "histological_grade",
                          "race",
                          "age",
                          "age_at_menarche",
                          "tumor_size_mm",
                          "days_to_last_followup",
                          "chemotherapy",
                          "radiotherapy",
                          "hormone_therapy",
                          "relapse_free_status",
                          "tumor_stage",
                          "methastasis",
                          "response_to_treatment",
                          "tabaquism",
                          "hispanic",
                          "pathological_history",
                          "family_pathological_hsitory",
                          "Relapse",
                          "TNBC_status",
                          "relapse_free_status"
                          )

features_to_engineer_val <- c("Age",
                              "Stage",
                              "Race"
                              )

# Transform the clinical variables to be compliant and homogeneous
RNA_clin_data <- feature_engineering_clinical_custom(RNA_clin_data, features_to_engineer)
RNA_clin_data_val <- feature_engineering_clinical_custom(RNA_clin_data_val, features_to_engineer_val)

head(RNA_clin_data)
head(RNA_clin_data_val)
```


### Data profiling report of the clinical data

Before running the data profiling report, let's verify the columns that could be dropped based on missing values > 60%.
```{r}
# Load the library
library(mde)

# Get a report of the missing variables per column
missing_summary <- na_summary(RNA_clin_data, sort_by = "percent_missing")
missing_summary_val <- na_summary(RNA_clin_data_val, sort_by = "percent_missing")
missing_summary
missing_summary_val
```


```{r}
# Saving the names of the variables with missing values above 75
vars_missing_above75 <- as.vector(missing_summary[missing_summary$percent_missing>=75,]$variable)
vars_missing_above75_val <- as.vector(missing_summary_val[missing_summary_val$percent_missing>=75,]$variable)
vars_missing_above75
vars_missing_above75_val
```

Drop the variables with above 75% missing data
```{r}
RNA_clin_data <- RNA_clin_data[,!(names(RNA_clin_data) %in% vars_missing_above75)]
RNA_clin_data_val <- RNA_clin_data_val[,!(names(RNA_clin_data_val) %in% c(vars_missing_above75_val, "Sample_geo_accession", "Response", "Sample_title", "Sample_description"))]
```

Generate Data profiling report
```{r}
library(DataExplorer)
create_report(RNA_clin_data)
create_report(RNA_clin_data_val)
```


### Handling missing values

Print the dimensions of the clinical data set to verify if the plot will correctly fit the screen or if it needs to be split.
```{r}
dim(RNA_clin_data)
```

Taking that into account, that is the quantity of clinical variables to plot for a better understanding of the distribution of the missing values in the clinical data.
```{r}
# Load the library for visualization
library(naniar)

# Plot the first half of the data
vis_miss(RNA_clin_data, sort_miss = T)
vis_miss(RNA_clin_data_val, sort_miss = T)
```
Most of the missing values seem to be aligned to similar samples, giving an indicator of being tied to the data source, which is acceptable as long as the resulting clusters are not influenced by the data source.

Verify the classes of the variables of interest.
```{r}
sapply(RNA_clin_data, class)
```

Separate numeric from categorical variables
```{r}
clinical_vars_names <- colnames(RNA_clin_data)
clinical_vars_names_val <- colnames(RNA_clin_data_val)

cat_vars_clin <- names(RNA_clin_data)[sapply(RNA_clin_data, is.character)]
cat_vars_clin_val <- names(RNA_clin_data_val)[sapply(RNA_clin_data_val, is.character)]
num_vars_clin <- c(names(RNA_clin_data)[sapply(RNA_clin_data, is.factor)], names(RNA_clin_data)[sapply(RNA_clin_data, is.numeric)]) 
num_vars_clin_val <- c(names(RNA_clin_data_val)[sapply(RNA_clin_data_val, is.factor)], names(RNA_clin_data_val)[sapply(RNA_clin_data_val, is.numeric)]) 
```

***

## Dimensionality reduction

There is a great need to develop analytical methodology to analyze and to exploit the information contained in gene expression data. Because of the large number of genes and the complexity of biological networks, clustering is a useful exploratory technique for analysis of gene expression data. Prior starting the clustering process, principal component analysis (PCA) is needed to reduce the dimensionality of our large and complex data set and allow us to explain the data in a matrix of fewer dimensions (more manageable and memory efficient).

### Principal components analysis (PCA)
To compute a PCA in R we use the prcomp() function. This function takes a matrix of data, where the columns are the variables that we want to use to transform our samples, which should be the rows of the matrix.

In this case, we look for similarities across our patients (samples = rows) based on gene expression (variables = columns). For that reason, we provide a transposed version of our table to the prcomp() function as shown in the cell below:
```{r}
val_mad <- tnbc_validation_dataset

t(train_mad)[1:10,1:10]
t(val_mad)[1:10,1:10]
```

Before proceeding with the numerical analysis, we remove the outlier sample (BA00439)
```{r}
val_mad <- val_mad[,!colnames(val_mad) %in% c("BA00439")]
RNA_clin_data_val <- RNA_clin_data_val[!row.names(RNA_clin_data_val) %in% c("BA00439"),]
```


Pass the transposed expression dataframe to the prcomp() function, so each row represents a sample and each column a gene.
```{r}
# Principal components analysis
x_train <- prcomp(t(train_mad), scale = T)
x_val <- prcomp(t(val_mad), scale = T)
```

Visualize eigenvalues (scree plot) to show the percentage of data variance explained by each principal component. We target to keep ~75-85% of the variance from the original dataset.
```{r}
scree_plot <- fviz_eig(x_train, addlabels=TRUE)
scree_plot_val <- fviz_eig(x_val, addlabels=TRUE)
scree_plot
scree_plot_val
```
As seen in the plot, we are not able to get the desired variance percentage even after adding up the first 2 Principal Components (PCs), therefore, more than 2 PCs are used for model training. On the other side, only two PCs are used to visualize the data points in a reader-friendly manner (Note: It is also possible to visualize the data in 3 dimensions if required to add an additional level of explainability to the graph).


### Graph of individuals
Plot the first two PCs to visualize the results of the dimensionality reduction technique on the gene expression data.
```{r}
# Plot the PCA
fviz_pca_ind(
  x_train,
  col.ind = "cos2",
  # Color by the quality of representation
  gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
  repel = T,
  # Avoid text overlapping,
  max.overlaps = Inf
)

# Plot the PCA
fviz_pca_ind(
  x_val,
  col.ind = "cos2",
  # Color by the quality of representation
  gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
  repel = T,
  # Avoid text overlapping,
  max.overlaps = Inf
)
```

Visual verification of the differences across different pairs of components.
This helps identifying differential descriptive Principal Components across different variables, if there is no clear difference, only the first 2 PCs are kept to continue the global analysis.
```{r}
vals_to_check <- as.factor(RNA_clin_data$tumor_stage)

# PC1 vs PC2
plot(
  x_train$rotation[, 1],
  x_train$rotation[, 2],
  xlab = "PCA component 1",
  ylab = "PCA component 2",
  col = vals_to_check
)

# PC1 vs PC3
plot(
  x_train$rotation[, 1],
  x_train$rotation[, 3],
  xlab = "PCA component 1",
  ylab = "PCA component 3",
  col = vals_to_check
)

# PC2 vs PC3
plot(
  x_train$rotation[, 2],
  x_train$rotation[, 3],
  xlab = "PCA component 2",
  ylab = "PCA component 3",
  col = vals_to_check
)
```
There isn't an apparent difference in the data explained by the first 6 components with the highest explained variance, so, we proceed with the analysis with a visualization focused on the first two PCs.

***

## Consensus Clustering

**Extract taken from the M3C package documentation (https://rdrr.io/bioc/M3C/f/vignettes/M3Cvignette.Rmd)**

Genome-wide expression data is used to stratify patients into classes using clustering algorithms for precision medicine. The Monti consensus clustering algorithm (Monti et al., 2003) is a widely applied method to identify the number of clusters (K) through the principle of stability selection. This algorithm works by resampling and clustering the data for each K and a NXN consensus matrix is calculated, where each element represents the fraction of times two samples clustered together. A perfectly stable matrix would consist entirely of 0s and 1s, representing all sample pairs always clustering together or not together over resampling iterations. 

The next step is to compare the stability of these consensus matrices to decide K. The Proportion of Ambiguous Clustering (PAC) score (Senbabaoglu et al., 2014) has been proposed to assess consensus matrix stability for each K, however, it has bias towards greater values of K. This is due to a general problem with this type of consensus clustering algorithm that occurs because as K increases the consensus matrix converges towards a matrix of perfect stability simply by chance. The alternative well used delta K metric to find K is subjective as it relies on finding an elbow point and has been demonstrated to be inferior to the PAC score. 

Monte Carlo reference-based consensus clustering (M3C) (John et al., 2018) was made to solve these problems by comparing the real stability scores with those expected under a random model. M3C uses a Monte Carlo simulation to generate null distributions of stability scores along the range of K which, by comparing with the real stability scores, are used to decide the optimal K and reject the null hypothesis K=1.

Choose the number of components that will represent ~85% of the variance of the data
```{r}
# Define a variable with the PCs to keep
PCs_to_keep = 285
PCs_to_keep_val = 78

# Print the cumulative explained variance of a range of PCs
summary(x_train)$importance[3, 1:PCs_to_keep][PCs_to_keep]
summary(x_val)$importance[3, 1:PCs_to_keep_val][PCs_to_keep_val]
```

### Consensus Clustering with PAC score as objective function

Define the annotation data frame with the clinical variables to test
```{r}
library(dplyr)

# Annotation dataframe
anno_df_m3c <- RNA_clin_data[,clinical_vars_names]
anno_df_m3c_val <- RNA_clin_data_val[,clinical_vars_names_val]

anno_df_m3c_val$ID <-
  mapvalues(
    anno_df_m3c_val$ID,
    c(
      "AICK.046.(13.006)",
      "AICK.050.(13.551)",
      "AICK.066.(13.2538)",
      "AICK.097.(14.2320)"
    ),
    c(
      "AICK.046..13.006.",
      "AICK.050..13.551.",
      "AICK.066..13.2538.",
      "AICK.097..14.2320."
    )
  )

row.names(anno_df_m3c_val) <- anno_df_m3c_val$ID

# Change gene expression data type to numeric
x_train[["x"]] <-
  mutate_all(as.data.frame(x_train[["x"]]), function(x)
    as.numeric(as.character(x)))

x_val[["x"]] <-
  mutate_all(as.data.frame(x_val[["x"]]), function(x)
    as.numeric(as.character(x)))
```

Perform consensus clustering on the normalized data
```{r}
library(dplyr)

# Pass the gene expression data frame to perform consensus clustering
# Where each row is a PC and each column is a sample.
res_train <- M3C(
  data.frame(t(x_train[["x"]][,1:PCs_to_keep])),
  des = anno_df_m3c,
  seed = 123,
  removeplots = TRUE,
  iters = 50,
  fsize = 8,
  lthick = 1,
  dotsize = 1.25
)

res_val <- M3C(
  data.frame(t(x_val[["x"]][,1:PCs_to_keep_val])),
  des = anno_df_m3c_val,
  seed = 123,
  removeplots = TRUE,
  iters = 50,
  fsize = 8,
  lthick = 1,
  dotsize = 1.25
)

# Save the optimal K
optimal_k_train = max(res_train[["assignments"]])
optimal_k_val = max(res_val[["assignments"]])
```

Also important is the relationship between the clinical variables and the discovered clusters. In this data we
want to compare with a categorical variable so perform a chi-squared test. We are reassured to see below
K=3 is highly significant.
```{r}

for (variable in cat_vars_clin[2:10]) {
  temp_var <- c()
  for (k in seq(2, 5)) {
    myresults <- res_train$realdataresults[[k]]$ordered_annotation
    chifit <-
      suppressWarnings(chisq.test(table(myresults[c('consensuscluster', variable)])))
    temp_var <- c(temp_var, round(chifit$p.value, 4))
  }
  print(variable)
  print(temp_var)
}

for (variable in cat_vars_clin_val[2:10]) {
  temp_var <- c()
  for (k in seq(2, 5)) {
    myresults <- res_val$realdataresults[[k]]$ordered_annotation
    chifit <-
      suppressWarnings(chisq.test(table(myresults[c('consensuscluster', variable)])))
    temp_var <- c(temp_var, round(chifit$p.value, 4))
  }
  print(variable)
  print(temp_var)
}
```


The results of the chi-squared test for the categorical variables of interest indicate that for K=3, the following categorical variables are significant:
- histological_type
- vital_status
- histological_grade
- hormone therapy
- menopausal_state

(Optional) Save the result of consensus clustering for later
```{r}
## Uncomment to save the result object to a local file
#saveRDS(res_train,
#        file = "~/TNBC_Research/code/csv_and_objects/clustering/consensus_clustering_M3C_170922.rds")
saveRDS(res_val,
        file = "~/TNBC_Research/code/csv_and_objects/clustering/consensus_clustering_val_M3C_171122.rds")
# Restore the object
res_train <- readRDS(file = "~/TNBC_Research/code/csv_and_objects/clustering/consensus_clustering_M3C_170922.rds")
res_val <- readRDS(file = "~/TNBC_Research/code/csv_and_objects/clustering/consensus_clustering_val_M3C_171122.rds")
```

### Display the consensus clustering scores for the selected K

The scores and p values for the PAC score objective function are contained within the res$scores object. We can see below the RCSI reaches a maxima at K = 3, the p_score supports this optimal K decision. This means the null hypothesis that K = 1 can be rejected for this data set because we have achieved significance (alpha=0.05) versus a data set with no clusters.
```{r}
# Consensus clustering scores
res_train$scores
res_val$scores
```

The stability index (RCSI) is the highest for K=3, as well as it being associated with the lowest P scores, which confirms the consensus clustering selection. 

### Visualize the consensus clustering plots

**1. CDF Plot**

In the CDF and following PAC plot we can see the inherent bias of consensus clustering where as K increases so does the apparent stability of the results (or CDF plot flatness), this we correct for by using a reference. This makes the method more sensitive to detection of the underlying structure in noisy data.

```{r}
res_train$plots[[1]]
res_val$plots[[1]]
```
The line starts flattening or stabilizing at K=3. Showing the performance of an optimal K.


**2. PAC Score**

This figure below shows the PAC score, we can see an elbow at K = 3 which is suggestive this is the best K. However, the bias of consensus clustering can be seen here as the PAC score naturally tends towards lower values as K increases (see above plot), making selecting K without taking this into account subject to bias. Selecting the minimal PAC score will only work when the clusters are very well separated.

```{r}
res_train$plots[[2]]
res_val$plots[[2]]
```

**3. Relative Cluster Stability Index (RCSI)**

The Relative Cluster Stability Index (RCSI) was derived and associated 95% confidence intervals which take into account the reference PAC scores using the reference mean. This metric is better than the PAC score for deciding class number, where the maximum value corresponds to the optimal K. In this example the RCSI has an optima at K=3. Either the *RCSI* or *P scores* can be used to select K. 

```{r}
res_train$plots[[3]]
res_val$plots[[3]]
```

**4. P score**

Calculate the P score from the distribution, here we display the P scores from the beta distribution. If none of the P scores reach significance over a reasonable range of K (e.g. 10), then we accept the null hypothesis. In this dataset, we can see K = 3 reaches signficance with an alpha of 0.05, therefore we can reject the null hypothesis K=1.
```{r}
res_train$plots[[3]]
res_val$plots[[3]]
```

After the analysis, we can be convinced that there are 3 clusters within this data set which are not likely to have
occurred by chance alone.


### Understanding M3C Outputs

The cell below extracts the ordered expression data and the ordered annotation data from the results object after running M3C for a 3 cluster solution. We then take a look at the annotation object M3C outputs, a consensus cluster column has been added by M3C.

Gather the RNA-seq data and clinical data from the clustering results as different variables.
```{r}
# RNA-seq data and cluster annotation
RNA_seq_data <-
  res_train$realdataresults[[optimal_k_train]][["ordered_data"]]
RNA_seq_data_val <-
  res_val$realdataresults[[optimal_k_val]][["ordered_data"]]
RNA_seq_cluster_annotation <-
  res_train$realdataresults[[optimal_k_train]][["ordered_annotation"]]
RNA_seq_cluster_annotation_val <-
  res_val$realdataresults[[optimal_k_val]][["ordered_annotation"]]

# Joining expression and cluster annotation
RNA_seq_merged <-
  as.data.frame(t(rbind(
    RNA_seq_data, t(RNA_seq_cluster_annotation)
  )))
RNA_seq_merged_val <-
  as.data.frame(t(rbind(
    RNA_seq_data_val, t(RNA_seq_cluster_annotation_val)
  )))

RNA_seq_merged_allgenes <-
  as.data.frame(merge(t(train_mad), RNA_seq_cluster_annotation, by = "row.names"))
RNA_seq_merged_allgenes_val <-
  as.data.frame(merge(t(val_mad), RNA_seq_cluster_annotation_val, by = "row.names"))
rownames(RNA_seq_merged_allgenes) <-
  RNA_seq_merged_allgenes$Row.names
rownames(RNA_seq_merged_allgenes_val) <-
  RNA_seq_merged_allgenes_val$Row.names

RNA_seq_merged_allgenes = subset(RNA_seq_merged_allgenes, select = -c(`Row.names`))
RNA_seq_merged_allgenes_val = subset(RNA_seq_merged_allgenes_val, select = -c(`Row.names`))

# Clinical data
RNA_clin_data <-
  merge(RNA_clin_data, RNA_seq_cluster_annotation, by = "row.names")
RNA_clin_data_val <-
  merge(RNA_clin_data_val, RNA_seq_cluster_annotation_val, by = "row.names")

rownames(RNA_clin_data) <- RNA_clin_data$Row.names
rownames(RNA_clin_data_val) <- RNA_clin_data_val$Row.names
```

Remove any possible duplicate column
```{r}
library(stringr)

RNA_clin_data <- RNA_clin_data %>% 
  rename_at(
    vars(ends_with(".x")),
    ~str_replace(., "\\..$","")
  ) %>% 
  select_at(
    vars(-ends_with(".y"))
  )

RNA_clin_data_val <- RNA_clin_data_val %>% 
  rename_at(
    vars(ends_with(".x")),
    ~str_replace(., "\\..$","")
  ) %>% 
  select_at(
    vars(-ends_with(".y"))
  )
```


Save the results of the 3 clusters in a set of variables
```{r}
# Training
data_train <-
  res_train$realdataresults[[optimal_k_train]]$ordered_data
annon_train <-
  res_train$realdataresults[[optimal_k_train]]$ordered_annotation
ccmatrix_train <-
  res_train$realdataresults[[optimal_k_train]]$consensus_matrix

# Validation
data_val <-
  res_val$realdataresults[[optimal_k_val]]$ordered_data
annon_val <-
  res_val$realdataresults[[optimal_k_val]]$ordered_annotation
ccmatrix_val <-
  res_val$realdataresults[[optimal_k_val]]$consensus_matrix
```

Consensus matrix heatmaps from M3C output with ComplexHeatmap.
```{r}
library(ComplexHeatmap)

ccl <- consensus_complex_heatmap(res_train, optimal_k_train)
print(ccl)
```
```{r}
ccl_val <- consensus_complex_heatmap(res_val, 3)
print(ccl_val)
```

From looking at the heatmap, we can discard that the clustering was biased by the batch effect of the data sources.

**K-means clustering**
We proceed to apply a K-means clustering procedure on the PCA selected components.
```{r}
set.seed(100)
k_train <- kmeans(x_train[["x"]][,1:PCs_to_keep],
                  centers = optimal_k_train
                  )
k_val <- kmeans(x_val[["x"]][,1:PCs_to_keep_val],
                  centers = optimal_k_val
                  )
```

We plot the resulting clusters
```{r}
# Add clusters obtained using the K-means algorithm
x_train$cluster <- factor(k_train$cluster)
eigenvalue <- round(get_eigenvalue(x_train), 1)
variance.percent_train <- eigenvalue$variance.percent

# Add clusters obtained using the K-means algorithm for validation
x_val$cluster <- factor(k_val$cluster)
eigenvalue_val <- round(get_eigenvalue(x_val), 1)
variance.percent_val <- eigenvalue_val$variance.percent
```

```{r}
library(ggpubr)
library(dplyr)

temp <- do.call("cbind", list(x_train[["x"]][,1:PCs_to_keep],as.data.frame(x_train$cluster)))
temp_val <- do.call("cbind", list(x_val[["x"]][,1:PCs_to_keep_val],as.data.frame(x_val$cluster)))

ggscatter(
  temp,
  x = "PC1",
  y = "PC2",
  color = "x_train$cluster",
  palette = "npg",
  ellipse = TRUE,
  ellipse.type = "convex",
  size = 1.5,
  legend = "right",
  ggtheme = theme_bw(),
  xlab = paste0("Dim 1 (", variance.percent_train[1], "% )"),
  ylab = paste0("Dim 2 (", variance.percent_train[2], "% )")
) +
  stat_mean(aes(color = `x_train$cluster`), size = 4)

ggscatter(
  temp_val,
  x = "PC1",
  y = "PC2",
  color = "x_val$cluster",
  palette = "npg",
  ellipse = TRUE,
  ellipse.type = "convex",
  size = 1.5,
  legend = "right",
  ggtheme = theme_bw(),
  xlab = paste0("Dim 1 (", variance.percent_val[1], "% )"),
  ylab = paste0("Dim 2 (", variance.percent_val[2], "% )")
) +
  stat_mean(aes(color = `x_val$cluster`), size = 4)
```

```{r}
# setting the data frames in a list
list_of_data = list(temp, RNA_clin_data)
list_of_data_val = list(temp_val, RNA_clin_data_val)

# this will get the intersection of the row.names for everything in the list
common_names = Reduce(intersect, lapply(list_of_data, row.names))
common_names_val = Reduce(intersect, lapply(list_of_data_val, row.names))
common_names
common_names_val
```

By looking at the previous plot, we confirm (once again), that the clustering was not biased due to the difference in data sources and gene expression techniques.

## Clinical data visualization per cluster
### Plotting categorical and numeric variables per cluster
```{r}
library(glue)
library(ggplot2)

clinical_plots(RNA_clin_data, clinical_vars_names, "counts", 3)
```

```{r}
clinical_plots(RNA_clin_data_val, clinical_vars_names_val, "counts", 2)
```

## SURVIVAL PLOT
### Survival curves from Kaplan-Meier analysis

The Kaplan–Meier estimator, also known as the product limit estimator, is a non-parametric statistic used to estimate the survival function from lifetime data. In medical research, it is often used to measure the fraction of patients living for a certain amount of time after treatment.
```{r}
library("survminer")
require("survival")

survival_clin_not_nulls = RNA_clin_data[is.na(RNA_clin_data$Surv_days)!=T & is.na(RNA_clin_data$Surv_event)!=T,c(25,26,27)]

# survival in days
fit_days <-
  survfit(Surv(Surv_days, Surv_event) ~ consensuscluster, data = survival_clin_not_nulls)
```

Plot the survival plot
```{r}
ggsurvplot(fit_days, data = RNA_clin_data)
```

Look at the statistical information of the monthly survival plot
```{r}
res.sum <- surv_summary(fit_days)
res.sum
```

### Survival curves from Cox Proportional Hazards Model

```{r}
# Fit Cox Model
cox <-
  coxph(Surv(Surv_days, Surv_event) ~ strata(consensuscluster),
        data = survival_clin_not_nulls)

summary(cox)
```


```{r}
library(simPH)

# Find predicted values
coxFit <- survfit(cox)

# Plot strata in a grid
ggfitStrata(coxFit, byStrata = TRUE, xlab = "Days")

# Plot all in one
ggfitStrata(coxFit, byStrata = FALSE, xlab = "Days")
```

But is there a more systematic way to look at the different covariates? As you might remember from one of the previous passages, Cox proportional hazards models allow you to include covariates. You can build Cox proportional hazards models using the coxph function and visualize them using the ggforest. These type of plot is called a forest plot. It shows so-called hazard ratios (HR) which are derived from the model for all covariates that we included in the formula in coxph. Briefly, an HR > 1 indicates an increased risk of death (according to the definition of h(t)) if a specific condition is met by a patient. An HR < 1, on the other hand, indicates a decreased risk.
```{r}
library("ggplot2")
library("survminer")
library("survival")

# Fit a Cox proportional hazards model
fit.coxph <- coxph(Surv(Surv_days, Surv_event) ~ consensuscluster, data = survival_clin_not_nulls)

ggforest(fit.coxph, data = survival_clin_not_nulls)
```

```{r}
summary(fit.coxph)
```

## Significance tests on clinical information

Take a look at the clinical data
```{r}
RNA_clin_data[0:10, clinical_vars_names] 
RNA_clin_data_val[0:10, clinical_vars_names_val] 
```

## Statistical tests on clinical data
```{r}
# Loading the required package for percentage tables
library(RcmdrMisc)
```

**Numeric variables**
Running the statistical tests for the numerical variables

Age
```{r}
clinical_test(
  variable_name = "age",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ age,
  predictor_type = "numerical",
  3
)

clinical_test(
  variable_name = "Age",
  clinical_df =  RNA_clin_data_val,
  formula = consensuscluster ~ Age,
  predictor_type = "numerical",
  2
)
```

For the age, the cluster 1 is significant compared to the other two clusters, including younger people (mean age ~52) compared to cluster 2 and 3 (mean age ~55).

Tumor size mm
```{r}
clinical_test(
  variable_name = "tumor_size_mm",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ tumor_size_mm,
  predictor_type = "numerical",
  3
)
```
For the tumor size in mm, none of the cluster comparisons show significance, with all of the means ranging between ~25-30 mm.


relapse_free_months
```{r}
clinical_test(
  variable_name = "relapse_free_months",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ relapse_free_months,
  predictor_type = "numerical",
  3
)
```
For the relapse free months, none of the cluster comparisons show significance, with a mean ranging from ~95-115 months.

Surv_days
```{r}
clinical_test(
  variable_name = "Surv_days",
  clinical_df =  RNA_clin_data[!is.na(RNA_clin_data[, "Surv_days"]), ],
  formula = consensuscluster ~ Surv_days,
  predictor_type = "numerical",
  3
)
```
For the survival months, the cluster 2 indicates a survival significance against cluster 1 and 2. The cluster 2 is associated with lower survival months (mean of ~72 months), compared to cluster 1 (mean of ~97 months) and cluster 3 (mean of ~103 months).


**Categorical variables**

histological_grade
```{r}
clinical_test(
  variable_name = "histological_grade",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ histological_grade,
  predictor_type = "categorical",
  3
)
```
The histological grade shows significance on the non-parametric tests with p-values < 0.05, even though the logistic regression model didn't provide the same results. Visualizing the distributions per cluster, the cluster 3 shows a higher relative percentage of histological type 2 patients (68%) compared to cluster 1 and 2 (~10%).

vital_status
```{r}
clinical_test(
  variable_name = "vital_status",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ vital_status,
  predictor_type = "categorical",
  3)
```
The vital status shows significance with p-values < 0.05. One of the most significant difference between cluster 2 and cluster 3 is the % of living patients, where cluster 2 has a higher % of living people (24%) compared to cluster 3 (~40%). On the other hand, the most significant differences between cluster 1 and cluster 2 is the % of living patients and the % of people that died of disease, where cluster 1 has a higher chance of dying of disease and of living (in general).


histological_type
```{r}
clinical_test(
  variable_name = "histological_type",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ histological_type,
  predictor_type = "categorical",
  3
)
```
The histological type shows significance with p-values < 0.05 between cluster 2 vs 3 and cluster 1 vs 3 on histological type == "Lobular" and "Mixed". Cluster 3 has a lower percentage of Ductal cases compared to the other two clusters.


tumor stage
```{r}
clinical_test(
  variable_name = "tumor_stage",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ tumor_stage,
  predictor_type = "categorical",
  3
)

clinical_test(
  variable_name = "Stage",
  clinical_df =  RNA_clin_data_val,
  formula = consensuscluster ~ Stage,
  predictor_type = "categorical",
  2
)
```
The tumor stage shows significance with p-values < 0.05 between cluster 1 vs cluster 3. Cluster 3 has a higher percentage of stage 2 cases (68%) compared to the cluster 3 (47%).

Race
```{r}
clinical_test(
  variable_name = "race",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ race,
  predictor_type = "categorical",
  3
)

clinical_test(
  variable_name = "Race",
  clinical_df =  RNA_clin_data_val,
  formula = consensuscluster ~ Race,
  predictor_type = "categorical",
  2
)
```


Relapse
```{r}
clinical_test(
  variable_name = "Relapse",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ Relapse,
  predictor_type = "categorical",
  3
)
```
The Relapse variable shows no significance among clusters.


menopausal_state
```{r}
clinical_test(
  variable_name = "menopausal_state",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ menopausal_state,
  predictor_type = "categorical",
  3
)
```
The cluster 3 has a higher percentage of post-menopausal patients (75%) compared to cluster 1 (56%).

chemotherapy
```{r}
clinical_test(
  variable_name = "chemotherapy",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ chemotherapy,
  predictor_type = "categorical",
  3
)
```
The cluster 1 has a higher percentage of patients treated with chemotherapy (61%) compared to cluster 1 (45%).

radiotherapy
```{r}
clinical_test(
  variable_name = "radiotherapy",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ radiotherapy,
  predictor_type = "categorical",
  3
)
```
The cluster 1 has a higher percentage of patients treated with radiotherapy (77%) compared to cluster 1 (65%).

hormone_therapy
```{r}
clinical_test(
  variable_name = "hormone_therapy",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ hormone_therapy,
  predictor_type = "categorical",
  3
)
```
There is recorded significance for the hormone therapy values between cluster 2 vs cluster 3, and cluster 1 vs cluster 3. The cluster 3 presents the highest percentage of patients treated with hormone therapy (60%) compared to the other two clusters (~21-26%).


relapse_free_status
```{r}
clinical_test(
  variable_name = "relapse_free_status",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ relapse_free_status,
  predictor_type = "categorical",
  3
)
```
The relapse free status variable shows no significance among clusters.

Surv event
```{r}
clinical_test(
  variable_name = "Surv_event",
  clinical_df =  RNA_clin_data,
  formula = consensuscluster ~ Surv_event,
  predictor_type = "categorical",
  3
)
```
The survival event variable shows no significance among clusters.

## Mutations Analysis
Download the mutations from the available sources. 

### Import mutations
```{r}
mut_Ref2 <-
  read.delim(
    file = "~/TNBC_Research/data/mutations_files/Ref2_mutations.txt",
    sep = "\t",
    header = T,
    stringsAsFactors = F,
    skip = 1
  )

print(mut_Ref2[0:10, 0:10])

mut_Ref4 <-
  read.delim(
    file = "~/TNBC_Research/data/mutations_files/Ref4_mutations.txt",
    sep = "\t",
    header = T,
    stringsAsFactors = F,
    skip = 0
  )

print(mut_Ref4[0:10, 0:10])

mut_TCGA <-
  read.delim(
    file = "~/TNBC_Research/data/mutations_files/TCGA_mutations.maf.txt",
    sep = "\t",
    header = T,
    stringsAsFactors = F
  )

print(mut_TCGA[0:10, 0:10])
```

Merging the mutation datasets
```{r}
# Columns in common with all the mutation datasets
merged_mut_cols <- intersect(colnames(mut_Ref2), colnames(mut_Ref4))
merged_mut_cols <- intersect(merged_mut_cols, colnames(mut_TCGA))

# Merged mutation datasets
merged_mut <-
  rbind(mut_Ref2[merged_mut_cols], mut_Ref4[merged_mut_cols])
merged_mut <- rbind(merged_mut, mut_TCGA[merged_mut_cols])

merged_mut[0:10, 0:10]
```

Check the data frame dimensions
```{r}
dim(merged_mut)
```


Defining the cluster groups with the patient IDs
```{r}
library(dplyr)
```

### Running the mutation analysis function
```{r}
mutation_analysis_res <- mutation_analysis(merged_mut, RNA_seq_merged_allgenes, 3, annon_train)
```


### T-test mutations merged

We run a t-test to know which genes change according to the mutations
```{r}
mut_rna_test = mutation_t_test(mutation_analysis_res$mut_matrix_rna, 
                               mutation_analysis_res$rna_mut)
```

Export the data frame with the p-values to a csv file
```{r}
mut_rna_test <- as.data.frame(mut_rna_test)
mut_rna_test$row_names <- rownames(mut_rna_test)

write.csv(
  as.data.frame(mut_rna_test),
  "C:\\Users\\victo\\OneDrive\\Documentos\\TNBC_research\\Clustering\\Mutations_merged_T_test.csv",
  row.names = FALSE
)
```

### Mutations per cluster
```{r}
mut_matrix_rna <- as.data.frame(mut_matrix_rna)
mut_matrix_rna[0:10,0:10]
```

```{r}
RNA_seq_merged <- as.data.frame(t(RNA_seq_merged))
RNA_seq_merged[0:10,0:10]
```

Slice the rnaseq matrices and mutation matrices into the different clusters
```{r}
# Cluster 1
mut_rnaseq_cluster_res <- create_cluster_rnaseq_matrix(rna_mut, mut_matrix_rna, 1)

mut_matrix_rna_cluster1 <- mut_rnaseq_cluster_res$mut_matrix_rna
mut_rnaseq_match_cluster1 <- mut_rnaseq_cluster_res$mut_rnaseq_match
rna_mut_cluster1 <- mut_rnaseq_cluster_res$rna_mut_cluster

# Cluster 2
mut_rnaseq_cluster_res <- create_cluster_rnaseq_matrix(rna_mut, mut_matrix_rna, 2)

mut_matrix_rna_cluster2 <- mut_rnaseq_cluster_res$mut_matrix_rna
mut_rnaseq_match_cluster2 <- mut_rnaseq_cluster_res$mut_rnaseq_match
rna_mut_cluster2 <- mut_rnaseq_cluster_res$rna_mut_cluster

# Cluster 3
mut_rnaseq_cluster_res <- create_cluster_rnaseq_matrix(rna_mut, mut_matrix_rna, 3)

mut_matrix_rna_cluster3 <- mut_rnaseq_cluster_res$mut_matrix_rna
mut_rnaseq_match_cluster3 <- mut_rnaseq_cluster_res$mut_rnaseq_match
rna_mut_cluster3 <- mut_rnaseq_cluster_res$rna_mut_cluster
```

### Chi2 mutations merged

We run a chi2 to know which genes change according to the mutations from cluster 1 vs cluster 2
```{r}
# We run a chi2 to know which genes change according to the mutations from cluster 1 vs cluster 2
res12 <- chi2_test_clusters_pair(mut_matrix_rna, mut_matrix_rna_cluster1, mut_matrix_rna_cluster2, c("1","2"))
significant_mutations_values12 <- res12$significant_mutations_values
mut_rna_test_12 <- res12$mut_rna_test
print(significant_mutations_values12)

# We run a chi2 to know which genes change according to the mutations from cluster 1 vs cluster 3
res13 <- chi2_test_clusters_pair(mut_matrix_rna, mut_matrix_rna_cluster1, mut_matrix_rna_cluster3, c("1","3"))
significant_mutations_values13 <- res13$significant_mutations_values
mut_rna_test_13 <- res13$mut_rna_test
print(significant_mutations_values13)

# We run a chi2 to know which genes change according to the mutations from cluster 2 vs cluster 3
res23 <- chi2_test_clusters_pair(mut_matrix_rna, mut_matrix_rna_cluster2, mut_matrix_rna_cluster3, c("2","3"))
significant_mutations_values23 <- res23$significant_mutations_values
mut_rna_test_23 <- res23$mut_rna_test
print(significant_mutations_values23)
```


Export the data frame with the p-values to a csv file
```{r}
mut_rna_test_12 <- as.data.frame(mut_rna_test_12)
mut_rna_test_12$row_names <- rownames(mut_rna_test_12)

mut_rna_test_13 <- as.data.frame(mut_rna_test_13)
mut_rna_test_13$row_names <- rownames(mut_rna_test_13)

mut_rna_test_23 <- as.data.frame(mut_rna_test_23)
mut_rna_test_23$row_names <- rownames(mut_rna_test_23)

write.csv(
  as.data.frame(mut_rna_test_12),
  "~/TNBC_research/code/csv_and_objects/mutations/Mutations_clusters1vs2_Chi2_test.csv",
  row.names = FALSE
)

write.csv(
  as.data.frame(mut_rna_test_13),
  "~/TNBC_research/code/csv_and_objects/mutations/Mutations_clusters1vs3_Chi2_test.csv",
  row.names = FALSE
)

write.csv(
  as.data.frame(mut_rna_test_23),
  "~/TNBC_research/code/csv_and_objects/mutations/Mutations_clusters2vs3_Chi2_test.csv",
  row.names = FALSE
)
```

Comparing the differentially expressed genes between both clusters
```{r}
significant_mutations_all <- unique(
  c(
    significant_mutations_names12,
    significant_mutations_names13,
    significant_mutations_names23
  )
)

cc1 <- colSums(t(mut_matrix_rna_cluster1))/
cc2 <- colSums(t(mut_matrix_rna_cluster2))/
cc3 <- colSums(t(mut_matrix_rna_cluster3))/

temp <-
  cbind(cc1[significant_mutations_all], cc2[significant_mutations_all], cc3[significant_mutations_all])

rownames(temp) <- significant_mutations_all
colnames(temp) <- c("cluster1", "cluster2", "cluster3")

print(temp)

plt <-
  barplot(
    t(temp),
    legend.text = c('cluster1', 'cluster2', 'cluster3'),
    xlab = "counts",
    horiz = T,
    las=2
  )
```

## DEGs (Differentially expressed genes among clusters)

TODO: Check the final results of the clusters expressions vs the resulting DEGs, we expect to have maximum one NA per row.
```{r}
library(limma)

design <- model.matrix( ~ 0 + RNA_clin_data$consensuscluster)
design[0:10, ]
```

```{r}
## the column names are a bit ugly, so we will rename
colnames(design) <- c("Cluster1", "Cluster2", "Cluster3")
design[0:10, ]
```

It has been demonstrated that our power to detect differential expression can be improved if we filter lowly-expressed genes prior to performing the analysis. Quite how one defines a gene being expressed may vary from experiment to experiment, so a cut-off that will work for all datasets is not feasible. Here we consider that around 50% of our genes will not be expressed, and use the median expression level as a cut-off.

```{r}
RNA_seq_exprs <-
  RNA_seq_merged_allgenes[which(rownames(RNA_seq_merged_allgenes) != "consensuscluster"),]
RNA_seq_exprs <-
  mutate_all(data.frame(RNA_seq_exprs), function(x)
    as.numeric(as.character(x)))

summary(RNA_seq_exprs[, 1:10])

## calculate median expression level
temp_median <- apply(RNA_seq_exprs, 2, median)
cutoff <- median(temp_median, na.rm = T)

## TRUE or FALSE for whether each gene is "expressed" in each sample
is_expressed <- RNA_seq_exprs > cutoff

## Identify genes expressed in more than 2 samples
keep <- colSums(is_expressed) > 2

## check how many genes are removed / retained.
table(keep)

## subset to just those expressed genes
RNA_seq_exprs <- RNA_seq_exprs[,row.names(as.data.frame(keep))]
```

The lmFit function is used to fit the model to the data. The result of which is to estimate the expression level in each of the groups that we specified.
```{r}
RNA_seq_exprs_no_consensuscluster <-
  t(RNA_seq_exprs)[!(row.names(t(RNA_seq_exprs)) %in% c("consensuscluster")), ]

## calculate relative array weights
aw <- arrayWeights(RNA_seq_exprs_no_consensuscluster, design)
aw[0:10]

fit <-
  limma::lmFit(RNA_seq_exprs_no_consensuscluster, design, weights = aw)
fit$coefficients[1:10, ]
```

In order to perform the differential analysis, we have to define the contrast that we are interested in. In our case we only have two groups and one contrast of interest. Multiple contrasts can be defined in the makeContrasts function.
 
```{r}
contrasts_c1c2 <- makeContrasts(Cluster1 - Cluster2, levels = design)
contrasts_c1c3 <-
  makeContrasts(Cluster1 - Cluster3, levels = design)
contrasts_c2c3 <-
  makeContrasts(Cluster2 - Cluster3, levels = design)

fitc1c2 <- contrasts.fit(fit, contrasts_c1c2)
fitc1c3 <- contrasts.fit(fit, contrasts_c1c3)
fitc2c3 <- contrasts.fit(fit, contrasts_c2c3)
```


Finally, apply the empirical Bayes’ step to get our differential expression statistics and p-values.
```{r}
fitc1c2 <- eBayes(fitc1c2)
fitc1c3 <- eBayes(fitc1c3)
fitc2c3 <- eBayes(fitc2c3)
```

We usually get our first look at the results by using the topTable command
```{r}
topTable(fitc1c2)
```
```{r}
topTable(fitc1c3)
```
```{r}
topTable(fitc2c3)
```

If we want to know how many genes are differentially-expressed overall we can use the decideTests function.

** Cluster1 - Cluster 2
```{r}
decideTests(fitc1c2)
```
```{r}
table(decideTests(fitc1c2))
```

** Cluster1 - Cluster 3
```{r}
decideTests(fitc1c3)
```
```{r}
table(decideTests(fitc1c3))
```

** Cluster2 - Cluster 3
```{r}
decideTests(fitc2c3)
```

```{r}
table(decideTests(fitc2c3))
```

### Further processing and visualisation of DE results
At the moment our results are not particularly easy to navigate as the only information to identify each gene is the identifier that the microarray manufacturer has assigned. Fortunately, the GEO entry contains extensive annotation that we can add. The annotation data can be retrieved with the fData function and we restrict to columns we are interested in using select.

For your own data, you will have to choose the columns that are of interest to you. You probably won’t have the same column headings used here.

Once an annotation data frame has been created, it can be assigned to our results.
```{r}
full_resultsc1c2 <- topTable(fitc1c2, number = Inf)
full_resultsc1c2 <- tibble::rownames_to_column(full_resultsc1c2, "ID")

full_resultsc1c3 <- topTable(fitc1c3, number = Inf)
full_resultsc1c3 <- tibble::rownames_to_column(full_resultsc1c3, "ID")

full_resultsc2c3 <- topTable(fitc2c3, number = Inf)
full_resultsc2c3 <- tibble::rownames_to_column(full_resultsc2c3, "ID")
```

The “Volcano Plot” function is a common way of visualising the results of a DE analysis. The x axis shows the log-fold change and the y axis is some measure of statistical significance, which in this case is the log-odds, or “B” statistic. A characteristic “volcano” shape should be seen.

First we create a data frame that we can visualise in ggplot2. Specifying the number argument to topTable creates a table containing test results from all genes. We also put the probe IDs as a column rather than row names.

The flexibility of ggplot2 allows us to automatically label points on the plot that might be of interest. For example, genes that meet a particular p-value and log fold-change cut-off. With the code below the values of p_cutoff and fc_cutoff can be changed as desired.

Furthermore, we can label the identity of some genes. Below we set a limit of the top “N” genes we want to label, and label each gene according to it’s Symbol.

```{r}
library(ggrepel)

## change according to your needs
p_cutoff <- 0.01
fc_cutoff <- 1.5
topN <- 20
```

Cluster 1 vs Cluster 2
```{r}
full_resultsc1c2 %>%
  mutate(Significant = p.adjust(P.Value, method="fdr") < p_cutoff, abs(logFC) > fc_cutoff) %>%
  mutate(Rank = 1:n(), Label = ifelse(Rank < topN, ID, "")) %>%
  ggplot(aes(
    x = logFC,
    y = -log10(P.Value),
    col = Significant,
    label = Label
  )) + geom_point() + geom_text_repel(col = "black")
```

Cluster 1 vs Cluster 3
```{r}
full_resultsc1c3 %>%
  mutate(Significant = p.adjust(P.Value, method="fdr") < p_cutoff, abs(logFC) > fc_cutoff) %>%
  mutate(Rank = 1:n(), Label = ifelse(Rank < topN, ID, "")) %>%
  ggplot(aes(
    x = logFC,
    y = -log10(P.Value),
    col = Significant,
    label = Label
  )) + geom_point() + geom_text_repel(col = "black")
```

Cluster 2 vs Cluster 3
```{r}
full_resultsc2c3 %>%
  mutate(Significant = p.adjust(P.Value, method="fdr") < p_cutoff, abs(logFC) > fc_cutoff) %>%
  mutate(Rank = 1:n(), Label = ifelse(Rank < topN, ID, "")) %>%
  ggplot(aes(
    x = logFC,
    y = -log10(P.Value),
    col = Significant,
    label = Label
  )) + geom_point() + geom_text_repel(col = "black")
```

We can filter according to p-value (adjusted) and fold-change cut-offs
```{r}
sign_genes_c1c2 <- filter(full_resultsc1c2, adj.P.Val < p_cutoff)
sign_genes_c1c3 <- filter(full_resultsc1c3, adj.P.Val < p_cutoff)
sign_genes_c2c3 <- filter(full_resultsc2c3, adj.P.Val < p_cutoff)
```

We save the results
```{r}
library(readr)
full_resultsc1c2 %>%
  write_csv(file="complete_DEGs_results_c1c2_18_sep_22.csv")

full_resultsc1c3 %>%
  write_csv(file="complete_DEGs_results_c1c3_18_sep_22.csv")

full_resultsc2c3 %>%
  write_csv(file="complete_DEGs_results_c2c3_18_sep_22.csv")
```


Comparing the diferentially expressed genes between all the clusters
```{r}
significant_genes <- filter(full_resultsc1c2, p.adjust(P.Value, method="fdr") < p_cutoff)$ID

cc1 <- colMeans(RNA_seq_exprs[RNA_seq_exprs$consensuscluster == 1])
cc2 <- colMeans(RNA_seq_exprs[RNA_seq_exprs$consensuscluster == 2])
cc3 <- colMeans(RNA_seq_exprs[RNA_seq_exprs$consensuscluster == 3])

temp <-
  cbind(cc1[significant_genes], cc2[significant_genes], cc3[significant_genes])

rownames(temp) <- significant_genes
colnames(temp) <- c("cluster1", "cluster2", "cluster3")

temp
```

### Heatmaps of selected genes

**Most differentially-expressed genes**
We have already created a table of differential expression results, which is ranked according to statistical significance.

To visualise the most differentially-expressed genes, we first need to extract their ID. These IDs should correspond to rows in the expression matrix.

In the code below we introduce a new column to the results which just gives a row number to each gene. We then filter to return data for the top N results. The pull function is used to extract the ID column as a variable.
```{r}
## Use to top 20 genes for illustration
topN <- 20

##
ids_of_interest12 <- mutate(full_resultsc1c2, Rank = 1:n()) %>%
  filter(Rank < topN) %>%
  pull(ID)
ids_of_interest13 <- mutate(full_resultsc1c3, Rank = 1:n()) %>%
  filter(Rank < topN) %>%
  pull(ID)
ids_of_interest23 <- mutate(full_resultsc2c3, Rank = 1:n()) %>%
  filter(Rank < topN) %>%
  pull(ID)
```

In order to label the heatmap in a useful manner we extract the corresponding gene symbols.
```{r}
gene_names12 <- mutate(full_resultsc1c2, Rank = 1:n()) %>% 
  filter(Rank < topN) %>% 
  pull(ID) 
gene_names13 <- mutate(full_resultsc1c3, Rank = 1:n()) %>% 
  filter(Rank < topN) %>% 
  pull(ID) 
gene_names23 <- mutate(full_resultsc2c3, Rank = 1:n()) %>% 
  filter(Rank < topN) %>% 
  pull(ID) 
```

The expression values for the IDs we have retrieved can be obtained by using the [..] notation to index the expression matrix.
```{r}
## Get the rows corresponding to ids_of_interest and all columns
gene_matrix12 <- t(RNA_seq_exprs)[ids_of_interest12,]
gene_matrix13 <- t(RNA_seq_exprs)[ids_of_interest13,]
gene_matrix23 <- t(RNA_seq_exprs)[ids_of_interest23,]
```

We now make the heatmap. A default colour scheme is used, but can be changed via the arguments. 
```{r}
pheatmap(gene_matrix12[,1:20],
     labels_row = gene_names,
     scale="row")
```
```{r}
pheatmap(gene_matrix13[,1:20],
     labels_row = gene_names,
     scale="row")
```
```{r}
pheatmap(gene_matrix23[,1:20],
     labels_row = gene_names,
     scale="row")
```
## PATHWAYS

First we get the genes set corresponding to the "homo sapiens" specie (human). 
```{r}
library(msigdbr)

human_gene_sets = msigdbr(species = "Homo sapiens", category = "H")
head(human_gene_sets)
```

Save the list of all the available gene symbols for the homo sapiens gene set
```{r}
m_list = human_gene_sets %>% split(x = .$gene_symbol, f = .$gs_name)
m_list
```

Take a look at the first rows of the normalized genes used for the clustering analysis.
```{r}
head(train_mad)
```


Filter the main genes dataframe to include only the genes mainly represented in each cluster.
```{r}
# Transform the m_list into a vector to perform the intersections
m_list_vector <-  unlist(m_list)

# All clusters intersection and filtering
intersecting_genes_all_clusters <-
  intersect(m_list_vector, rownames(train_mad))

genes_df_all_clusters <-
  train_mad[row.names(train_mad) %in% intersecting_genes_all_clusters, ]
```

# TODO
 -  Calcular score para cada muestra, sin importar si son significativos o no
 -  Comparacion entre clusters, no de cada uno de los clusters
 -  Input = Matriz de expresion de genes utilizada para el clustering
 
 - Survival sin sujetos intercluster

Now, lets explore the pathways for each cluster
```{r}
library(msigdbr)

# all genes
hallmarks_ssgsea_cluster <- GSVA::gsva(as.matrix(train_mad), 
                               gset.idx.list = m_list, 
                               method= "ssgsea",
                               verbose= FALSE)

```

```{r}
## fit the same linear model now to the GSVA enrichment scores
fit_gsea <- lmFit(hallmarks_ssgsea_cluster, design)
## estimate moderated t-statistics
fit_gsea <- eBayes(fit_gsea)
```

Clusters
```{r}
topTable(fit_gsea, coef="Cluster1")
topTable(fit_gsea, coef="Cluster2")
topTable(fit_gsea, coef="Cluster3")
```


